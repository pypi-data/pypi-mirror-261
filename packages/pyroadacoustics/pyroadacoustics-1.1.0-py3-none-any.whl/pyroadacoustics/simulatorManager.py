import numpy as np
import scipy.signal
import math
from collections import deque
from typing import Tuple, Union

from .delayLine import DelayLine
from .material import Material

class SimulatorManager:
    """
    This class defines the simulation logic. It contains all the methods and components that are needed
    to run the acoustic simulation in the defined scenario, and compute the output signals. The
    acoustic scene defined in the `Environment` module contains a single sound source, an array of microphones, 
    and some additional parameters (e.g. a sampling frequency, the atmospheric conditions, the road surface properties,
    a background noise). The `SimulatorManager` simulates the propagation of sound from the moving source to a 
    single, static microphone, exploiting the scene parameters that it receives at the time of its initialization.

    The received signal will contain two different components: the direct sound, propagating directly from 
    the source (assumed to be omnidirectional and point-like) to the microphone (assumed
    to be omnidirectional and point-like too), and the sound reflected by the road surface. In order to simulate the
    reflection, the simulator exploits the Image-Source Method (ISM): a virtual source is generated by reflecting the
    position of the real sound source w.r.t the road surface, and the reflected sound is assumed to be emitted by
    this source as if it was emitting in the free-field. The sound produced the image source is then filtered by a 
    set of FIR filters that simulate the asphalt surface absorption and the attenuation due to the propagation of
    the sound through the air.
    
    The simulation is divided in two separate phases:
    * During the `initialization` phase, the `DelayLine` components used to simulate the sound propagation delay
    are instantiated, and the initial delays between the microphone, the sound source and the reflection point are
    computed.
    * During the `update` phase, first the signal emitted by the source is written on the two `DelayLine` instances 
    controlling the direct and reflected sound propagation delays. Then, the delays are updated according to the 
    new position of the moving source, together with the distances source -> receiver, image source -> road surface 
    and road surface -> receiver. The corresponding delayed signal samples are read from the `DelayLines` and filtered
    via a set of filters simulating the (angle-dependent) asphalt reflection and the air absorption. Finally, the
    signal received by the microphone is computed by summing the direct and the reflected components of the simulated
    sound field.

    Attributes
    -------
    c: float
        Speed of sound in the air
    fs: int
        Sampling frequency used in the simulations
    Z0: float
        Acoustic impedance of air
    road_material: Material
        Asphalt type of the road surface, defined by its absorption and reflection properties
    primaryDelayLine: DelayLine
        Primary `DelayLine` component, used to compute delays corresponding to propagation of sound between source
        and receiver on direct path, and between image source and road surface, on reflected path
    secondaryDelayLine: DelayLine
        Secondary `DelayLine` component, used to compute delay corresponding to the propagation of sound on the 
        reflected path from the reflection point on the road surface to the microphone position
    airAbsorptionCoefficients: np.ndarray
        1D array containing the air absorption coefficients computed at a set of frequency bands covering the 
        range from 0 to fs/2
    asphaltReflectionFilterTable: np.ndarray
        2D array containing the asphalt reflection filters computed at different reflection angles. The filters
        have a fixed number of taps ntaps = 10, and their impulse response at a set of angles from -89 to + 89 degrees
        is pre-computed and stored in this table in order to speed up the execution.
    simulation_params: dict
        Dictionary containing the keys:
        * `interp_method`: str, defines the interpolation method used in the delay line interpolated reads
        * `include_reflected_path`: bool, if `True` the received sample includes both the direct and the reflected sound,
        otherwise it includes just the direct sound
        * `include_air_abosrption`: bool, if `True` the air absorption is included in the simulation

    Methods
    ------
    initialize(src_pos: np.ndarray, mic_pos: np.ndarray):
        Sets the initial delays in the primary and secondary delay lines, according to the (initial) position of the
        source and the position of the microphone used for the current simulation
    update(src_pos: np.ndarray, mic_pos: np.ndarray, signal_sample: float):
        Updates delays on the primary and secondary delay lines given the new position of the source, and produces
        a new sample received by the microphone
    """

    def __init__(
            self,
            c: float,                                   # speed of sound in air 
            fs: int,                                    # sampling frequency
            Z0: int,                                    # characteristic impedance of air
            road_material: Union[Material, int],        # Absorption properties of road surface
            airAbsorptionCoefficients: np.ndarray,
            simulation_params: dict = {
                "interp_method": "Sinc",
                "include_reflected_path": True,
                "include_air_absorption": True,
            },
        ) -> None:
        """
        Creates a `SimulatorManager` object containing all the methods and attributes required to run the acoustic
        simulation. When the constructor is called, the environmental parameters previously defined in the object
        `Environment` are stored into the simulator manager (c, fs, Z0, road_material, airAbsorptionCoefficients). 
        In addition, the two `DelayLine` objects required for the simulation are instantiated as empty circular 
        arrays with 48000 entries. The `asphaltReflectionFilterTable` is pre-computed and stored as an instance 
        attribute containing the FIR filter coefficients that describe asphalt reflection at different angles of
        incidence of the sound waves. This will result in a reduction of the computational load,
        since the computation of a new filter depending on the instantaneous incidence angle is turned into a 
        table lookup. The set of considered incidence angles is stored in `_theta_vector` in degrees. In order to
        reduce the computational complexity, also the pseudo inverse matrix, needed by the least squares filter design
        method in the air absorption filters evaluation, is pre-computed. Finally, a set of auxiliary buffers are 
        instantiated and will be used for filtering purpose.

        Parameters
        ----------
        c : float
            Speed of sound in the air
        fs: int
            Sampling frequency used in the simulation
        Z0: float
            Characteristic impedance of the air at the chosen environmental conditions (i.e. T, p)
        road_material: Material or int 
            * Material object defining the absorption and reflection properties of the road surface
            * int defining the flow resistance of the road surface
        airAbsorptionCoefficients: np.ndarray
            1D Array containing the air absorption coefficients computed in the defined frequency bands at the chosen 
            environmental conditions (i.e. T, p, rel. humidity)
        
        Raises
        ------
        KeyError:
            If simulation_params does not contain keys `interp_method`, `include_reflected_path` and 
            `include_air_absorption`.
        """
        self.c = c
        self.fs = fs
        self.Z0 = Z0
        self.road_material = road_material
        self.airAbsorptionCoefficients = airAbsorptionCoefficients

        # Define simulation parameters
        if ("interp_method" not in simulation_params or "include_reflected_path" 
            not in simulation_params or "include_air_absorption" not in simulation_params):
            raise KeyError("simulation_params must be a dict with keys 'interp_method' (string),"
              "'include_reflection_path' (bool) and 'include_air_absorption (bool'")
        self.simulation_params = simulation_params

        # Instantiation of two delay lines used for the simulations
        self.primaryDelLine = DelayLine(N = 48000, num_read_ptrs = 2, 
            interpolation = self.simulation_params["interp_method"]) 
        self.secondaryDelLine = DelayLine(N = 48000, num_read_ptrs = 1, 
            interpolation = self.simulation_params["interp_method"])

        # Array containing all possible incidence angles for pre-computed reflection filter table
        self._theta_vector = np.arange(-89,90,1)

        if isinstance(road_material, int):
            n_taps_refl = 40    
            self.f_tmp = np.linspace(0.001,self.fs/2,512)
            self.sigma = road_material
            self.Z = 1 + 9.08 * ((1000.0 * self.f_tmp)/self.sigma)**(-0.75) - 11.9 * 1j * ((1000.0 * self.f_tmp)/self.sigma) ** (-0.73)
            self.w_tmp, self.Rp = self._precompute_complex_angle_reflection_filter_table()
        if isinstance(road_material, Material):
            # Instantiation of table containing asphalt reflection filters
            n_taps_refl = 11
            self.realAsphaltReflectionFilterTable = self._precompute_real_angle_reflection_filter_table(ntaps = n_taps_refl)
        
        # Instantiation of table containing source directivity filters - cars
        self.directivity_filter_table_road_tire, self.delta_L_road_tire = self._compute_directivity_filter_table_road_tire(11)
        self.directivity_filter_table_engine, self.delta_L_engine = self._compute_directivity_filter_table_engine()
        
        self._readBufDir1 = deque(np.zeros(11), maxlen=11)
        self._readBufDir2 = deque(np.zeros(11), maxlen=11)

       
        # Buffers to store previous data read from delay lines for filtering purpose
        self._read1Buf = deque(np.zeros(11), maxlen=11)
        self._read2Buf = deque(np.zeros(11), maxlen=11)
        self._read3Buf = deque(np.zeros(n_taps_refl), maxlen=n_taps_refl)
        self._read4Buf = deque(np.zeros(11), maxlen=11)

        # Compute air absorption filter 
        freqs = np.linspace(0, self.fs / 2, len(airAbsorptionCoefficients))
        w = 2 * np.pi * freqs / (fs / 2)
        
        # Filter order - air absorption
        L_air = 10

        # Matrix A
        A = np.zeros((len(w),int(L_air/2 + 1)))
        A[:,0] = 1
        for i in range(len(w)):
            for j in range(1,int(L_air/2 + 1)):
                A[i,j] = 2 * math.cos(w[i] * j)
        self._pseud_A = np.linalg.inv(A.T.dot(A)).dot(A.T)
        

    def initialize(self, src_traj: np.ndarray, mic_pos: np.ndarray, mic_orientation: float, mic_dir_pattern: str, src_orientation: float, src_dir_pattern: str) -> None:
        """
        Computes the propagation delays along the paths:
        * Direct path from source initial position to microphone
        * Path from image source position to incidence point on asphalt surface, along reflected path
        * Path from incidence point on asphalt surface to microphone, along reflected path
        Sets the corresponding initial delays on the two delay lines.

        This method must be called at the start of every simulation to set the initial conditions that
        ensure no discontinuity is generated at the first simulation instant.

        Parameters
        ----------
        src_traj : np.ndarray
            2D array containing the cartesian coordinates [x,y,z] of each point of the trajectory of the source
        mic_pos : np.ndarray
            1D array containing the cartesian coordinates [x,y,z] denoting the position of the microphone
        mic_orientation: float
            Orientation angle in degrees, referred to positive x axis (i.e. 0 degrees corresponds to microphone oriented along the positive x axis)
        mic_dir_pattern: str
            Directivity pattern of the microphone (can be omnidirectional, subcardioid, cardioid, supercardioid, hypercardioid, figure 8)
        src_orientation: float
            Float value expressing the orientation angle, in degrees, of the source w.r.t the movement direction, computed as the direction of the 
            vector pointing from the initial position to the next trajectory point
        src_dir_pattern: str
            Directivity pattern of the source (can be omnidirectional, subcardioid, cardioid, supercardioid, hypercardioid, figure 8)
        """

        # Define orientation vector (unit vector pointing towards the orientation direction of the microphone)
        self.mic_orientation_vector = np.array([np.cos(np.deg2rad(mic_orientation)), np.sin(np.deg2rad(mic_orientation))])
        self.src_orientation_angle = np.deg2rad(src_orientation)

        # Define directivity pattern
        self.mic_dir_pattern = mic_dir_pattern
        self.src_dir_pattern = src_dir_pattern
        
        # Compute direct distance and delay
        _, tau = self._compute_delay(src_traj[0,:], mic_pos)
        
        # Compute incidence angle
        theta = self._compute_angle(src_traj[0,:], mic_pos)

        # Compute distance and delay between src and reflection point
        a = src_traj[0,2] / math.sin(theta)
        tau_1 = a / self.c
        
        # Compute distance and delay between reflection point and microphone
        b = src_traj[0,2] / math.sin(theta)
        tau_2 = b / self.c

        # Set initial delays
        self.primaryDelLine.set_delays(np.array([tau * self.fs, tau_1 * self.fs]))
        self.secondaryDelLine.set_delays(np.array([tau_2 * self.fs]))

        # Buffer to store previous source position for directivity estimation
        if src_traj[1,0] == src_traj[0,0]:
            # Static source
            self.static_src = True
        else:
            self.static_src = False
        self._prev_src_pos = np.array([src_traj[1,0] - 2 * (src_traj[1,0] - src_traj[0,0]), src_traj[1,1] - 2 * (src_traj[1,1] - src_traj[0,1]), src_traj[1,2]])
        self._prev_src_dist, _ = self._compute_delay(self._prev_src_pos, mic_pos)
        
    def update(self, src_pos: np.ndarray, mic_pos: np.ndarray, signal_sample: float) -> float:
        """
        This method is used to compute the output of one instant of the simulation. It takes as inputs the instantaneous
        positions of the source and of the microphone used in the current simulation, and the sample of the source
        signal emitted at the considered instant. It then performs the update of the `DelayLine` objects, writing the new 
        sample `signal_sample` on the primary line, and computes the relative distances and delays between the source,
        the road surface at the incidence point, and the microphone, together with the incidence angle. According to
        these delays, the `DelayLine` read pointers positions are updated. Then, the output sample received at the
        microphone position is computed as a sum of two components:
        * the direct component of the sound field, filtered with by air absorption filter ,depending on the distance
        between the source and the microphone, and attenuated depending on the travelled distance;
        * the reflected component: the reflected sound is analyzed using a cascade of 3 filters and two multiplications.
        The reflected sound wave travels from the source to the road surface, along a trajectory computed 
        using the principles of geometrical acoustics. This path is represented by a propagation delay, a filter that
        models the air absorption depending on the distance between the source and the incidence point, and an
        attenuation factor depending on the same travelled distance. At the incidence point, the sound wave is 
        filtered with a second FIR filter representing the asphalt reflection, depending on the road surface material 
        and on the incidence angle. After the reflection, the sound wave travels from the reflection point to the 
        microphone, along a path modeled by a second delay element, a second air absorption filter depending on the
        distance between reflection point and microphone, and a second attenuation factor depending on the same
        distance. 

        The two components are summed to produce the output sample, that is returned by the update function. All the 
        filtering operations are performed in the time domain, as the convolution between the considered signals 
        and the FIR filters.

        Parameters
        ----------
        src_pos : np.ndarray
            1D array containing the cartesian coordinates [x,y,z] denoting the position of the sound source
        mic_pos : np.ndarray
            1D array containing the cartesian coordinates [x,y,z] denoting the position of the microphone
        signal_sample : float
            Sample produced by the source at the considered instant

        Returns
        -------
        float
            Sample of the signal recorded by the cosidered microphone at the given time instant
        """

        # Compute direct distance and delay
        d, tau = self._compute_delay(src_pos, mic_pos)

        # Compute incidence angle
        theta = self._compute_angle(src_pos, mic_pos)

        # Compute microphone directivity attentuation
        mic_dir_factor = self._compute_mic_dir_factor(src_pos, mic_pos, d, self.mic_orientation_vector, self.mic_dir_pattern)

        # Compute distance and delay between src and reflection point
        a = src_pos[2] / math.sin(theta)
        tau_1 = a / self.c
        
        # Compute distance between reflection point and microphone
        b = mic_pos[2] / math.sin(theta)
        tau_2 = b / self.c

        # Compute source directivity attenuation
        if self.src_dir_pattern != 'road_tire' and self.src_dir_pattern != 'engine':
            src_dir_factor = self._compute_src_dir_factor(d, mic_pos, src_pos, self.src_orientation_angle)
            signal_sample = src_dir_factor * signal_sample

        # Update delays and get new sample reads
        y_primary = self.primaryDelLine.update_delay_line(signal_sample, np.array([tau * self.fs, 
            tau_1 * self.fs]))

        # Store the read samples in a circular array for filtering with air absorption and asphalt reflection
        self._read1Buf.appendleft(y_primary[0])
        self._read2Buf.appendleft(y_primary[1])
        
        y_received = 0
        ### DIRECT PATH ###

        if self.simulation_params["include_air_absorption"]:
            # Attenuation due to air absorption
            filt_coeffs = self._compute_air_absorption_filter(d, numtaps = 11)
            sample_eval = filt_coeffs.dot(list(self._read1Buf))
        else:
            sample_eval = self._read1Buf[0]
        
        if self.src_dir_pattern == 'road_tire' or self.src_dir_pattern == 'engine':
            self._readBufDir1.appendleft(sample_eval)
            if self.static_src:
                phi = int(np.rad2deg(np.pi - np.arccos((src_pos[:2] - mic_pos[:2]) @ np.array([1,0]) / d)))
            else:
                # Compute modulus of vector from past src_pos to current src_pos (speed direction)
                pos_variation_mod = math.sqrt(np.sum((src_pos - self._prev_src_pos) ** 2))
                
                # Compute angle between direction of source velocity and mic-to-src direction using cosine law
                phi = int(np.rad2deg(np.arccos((self._prev_src_dist ** 2 + pos_variation_mod ** 2 - d ** 2) / (2 * self._prev_src_dist * pos_variation_mod))))
            
            psi = int(np.rad2deg(np.arcsin((mic_pos[2] - src_pos[2])/d)))
            if self.src_dir_pattern == 'road_tire':
                filt_coeffs = self.directivity_filter_table_road_tire[phi, psi]
                delta_L = self.delta_L_road_tire[phi, psi]
            
                bpf_signal = filt_coeffs.dot(list(self._readBufDir1))

                sample_eval = sample_eval - bpf_signal + bpf_signal * 10 ** (delta_L / 20)
            else:
                filt_coeffs = self.directivity_filter_table_engine[phi, psi]
                delta_L = self.delta_L_engine[phi, psi]
            
                sample_eval = sample_eval * 10 ** (delta_L / 20)
        # Attenuation due to distance
        att = self._compute_sound_attenuation(d)

        # Direct Path Output Sample
        y_dir =  att * sample_eval

        ### REFLECTED PATH ###
        if self.simulation_params["include_reflected_path"]:
        # 1. From Source to Road Surface

            if self.simulation_params["include_air_absorption"]:

                # Attenuation due to air absorption
                filt_coeffs = self._compute_air_absorption_filter(a, numtaps = 11)
                sample_eval = filt_coeffs.dot(list(self._read2Buf))
            else:
                sample_eval = self._read2Buf[0]
            
            # Attenuation due to distance
            att = self._compute_sound_attenuation(a)
            sample_eval = att * sample_eval
            
            # Write output of first filter in buffer, to be able to apply second filter in cascade
            self._read3Buf.appendleft(sample_eval)

            # 2. Asphalt Absorption
            asphalt_filter_coeffs = self._get_asphalt_reflection_filter(90 - math.degrees(theta), a+b)
            
            sample_eval = asphalt_filter_coeffs.dot(list(self._read3Buf))
            
            
            # 3. Second path in air --> Secondary Delay Line
            y_secondary = self.secondaryDelLine.update_delay_line(sample_eval, np.array([tau_2 * self.fs]))

            # Store output of secondary delay line in buffer for cascade air abs filter
            self._read4Buf.appendleft(y_secondary[0])

            # 4. From Road Surface to Receiver
            if self.simulation_params["include_air_absorption"]:
                # Attenuation due to air absorption
                filt_coeffs = self._compute_air_absorption_filter(b, numtaps = 11)
                sample_eval = filt_coeffs.dot(list(self._read4Buf))
            else:
                sample_eval = self._read4Buf[0]
            
            if self.src_dir_pattern == 'road_tire' or self.src_dir_pattern == 'engine':
                self._readBufDir2.appendleft(sample_eval)

                psi = int(np.rad2deg(np.arcsin((mic_pos[2])/b)))
                if self.src_dir_pattern == 'road_tire':
                    filt_coeffs = self.directivity_filter_table_road_tire[phi, psi]
                    delta_L = self.delta_L_road_tire[phi, psi]
            
                    bpf_signal = filt_coeffs.dot(list(self._readBufDir2))

                    sample_eval = sample_eval - bpf_signal + bpf_signal * 10 ** (delta_L / 20)
                else:
                    filt_coeffs = self.directivity_filter_table_engine[phi, psi]
                    delta_L = self.delta_L_engine[phi, psi]
                
                    sample_eval = sample_eval * 10 ** (delta_L / 20)
                
            # Attenuation due to distance
            att = self._compute_sound_attenuation(b)

            y_refl = att * sample_eval

            # Compute received sample as sum of direct and reflected path outputs
            y_received = y_refl
        
        y_received = mic_dir_factor * (y_received + y_dir)

        # Update buffer for previous distance and position
        self._prev_src_dist = d
        self._prev_src_pos = src_pos

        return y_received
    
    def _compute_air_absorption_filter(self, distance: float, numtaps: int) -> np.ndarray:
        """
        Computes air absorption filter as a FIR filter with `numtaps` coefficients. The filter depends
        on the distance between the source and the receiver.

        Parameters
        ----------
        distance : float
            Distance travelled by the sound wave, in meters
        numtaps : int
            Number of coefficients of the FIR filter

        Returns
        -------
        np.ndarray
            1D array containing `numtaps` FIR filter coefficients modelling air absorption
        """
        filt_coeffs = np.empty(numtaps, np.float64)
        alpha = 10 ** (-self.airAbsorptionCoefficients * distance / 20)     # Convert coeffs in dB to linear scale
        filt_coeffs[int((numtaps+1)/2)-1:] = self._pseud_A.dot(alpha)
        filt_coeffs[0:int((numtaps+1)/2)-1] = np.flip(filt_coeffs[int((numtaps+1)/2):])
        
        return filt_coeffs

    def _precompute_real_angle_reflection_filter_table(self, ntaps: int = 11) -> np.ndarray:
        """
        Computes the coefficients of the FIR filters modelling asphalt reflection, at a set of different
        incidence angles, and stores them in a table. Each row of the table contains the `ntaps` FIR filter 
        corresponding to a different incidence angle. The set of angles is defined in `self._theta_vector`.

        The filter coefficients are computed using the `scipy.signal.firwin2` method, given the reflection coefficients
        computed in the frequency bands `center_freqs`, defined in the instance attribute `road_material`. 
        The reflection coefficients are derived from the  absorption coefficients of the road surface, defined
        in the instance attribute `road_material`. The road surface is assumed to be  locally reactive, meaning 
        that its impedance Z does not depend on the incidence angle.

        Parameters
        ----------
        ntaps : int
            Number of FIR filter coefficients, must be odd

        Returns
        -------
        np.ndarray
            2D Array with len(self._theta_vector) rows, each containing `ntaps` FIR filter coefficients corresponding
            to each angle defined in `self._theta_vector`
        """
        
        Z0 = self.Z0
        refl = np.sqrt(1 - np.array(self.road_material.absorption["coeffs"]))
        
        # The impedance does not depend on the angle of incidence -> locally reactive surface
        Z = - Z0 * (refl + 1) / (refl-1)
        
        b_fir = np.zeros((len(self._theta_vector), ntaps))
        
        # Compute filters coefficients for all thetas
        for idx, theta in enumerate(self._theta_vector):
            R = np.abs((Z * np.cos(math.radians(theta)) - Z0) / (Z * np.cos(math.radians(theta)) + Z0))
            b_fir[idx] = scipy.signal.firwin2(ntaps, np.array(self.road_material.absorption["center_freqs"]) 
                / (self.fs/2), R)
        
        return b_fir

    def _compute_sound_attenuation(self, distance: float) -> float:
        """
        Computes the attenuation of sound due to its propagation in the empty space. This attenuation depends
        only on the distance between the source and the receiver and is computed assuming a spherical propagation
        model.

        Parameters
        ----------
        distance : float
            Relative distance between the sound source and the receiver

        Returns
        -------
        float
            Attenuation factor
        """
        return 1 / (distance)
    
    def _compute_delay(self, src_pos: np.ndarray, mic_pos: np.ndarray) -> Tuple[float, float]:
        """
        Computes the distance between the source and the microphone, and the time needed by the sound to travel 
        from source to microphone, given their distance and the speed of sound in air.

        Parameters
        ----------
        src_pos : np.ndarray
            1D array containing the cartesian coordinates [x,y,z] denoting the position of the source
        mic_pos : np.ndarray
            1D array containing the cartesian coordinates [x,y,z] denoting the position of the microphone

        Returns
        -------
        Tuple[float, float]
            Tuple containing the distance between source and microphone (in meters) and the time delay (in seconds)
        """

        d = math.sqrt(np.sum((src_pos - mic_pos) ** 2))
        tau = d / self.c
        return d, tau
    
    def _compute_angle(self, src_pos: np.ndarray, mic_pos: np.ndarray) -> float:
        """
        Computes the incidence angle of the sound wave travelling from the source to the road surface, along the
        reflected path connecting the source to the microphone with a single reflection generated by the road.

        Parameters
        ----------
        src_pos : np.ndarray
            1D array containing the cartesian coordinates [x,y,z] denoting the position of the source
        mic_pos : np.ndarray
            1D array containing the cartesian coordinates [x,y,z] denoting the position of the microphone

        Returns
        -------
        float
            Incidence angle of sound wave travelling from source to road surface along reflected path, in radians
        """

        # Distance between image and microphone
        dist = math.sqrt(np.sum(((src_pos - np.array([0, 0 , 2*src_pos[2]])) - mic_pos) ** 2))
        # Incidence angle
        theta = math.asin((src_pos[2] + mic_pos[2]) / dist)
        return theta
    
    def _compute_mic_dir_factor(self, src_pos: np.ndarray, mic_pos: np.ndarray, distance: float, orientation: np.ndarray, dir_pattern: str) -> float:
        '''
        Computes the attenuation factor due to directivity, depending on the microphone directivity pattern 
        and on the angle between the microphone orientation and the source
        '''
        # Retrieve angle on Horizontal axis, assume rotational invariance along vertical direction
        if dir_pattern == 'omnidirectional':
            dir_factor = 1
        elif dir_pattern == 'subcardioid':
            cos_theta = (src_pos[:2] - mic_pos[:2]) @ orientation / distance
            dir_factor = 0.75 + 0.25 * cos_theta
        elif dir_pattern == 'cardioid':
            cos_theta = (src_pos[:2] - mic_pos[:2]) @ orientation / distance
            dir_factor = 0.5 + 0.5 * cos_theta
        elif dir_pattern == 'supercardioid':
            cos_theta = (src_pos[:2] - mic_pos[:2]) @ orientation / distance
            dir_factor = 1/3 + 2/3 * cos_theta
        elif dir_pattern == 'hypercardioid':
            cos_theta = (src_pos[:2] - mic_pos[:2]) @ orientation / distance
            dir_factor = 0.25 + 0.75 * cos_theta
        elif dir_pattern == 'figure8':
            cos_theta = (src_pos[:2] - mic_pos[:2]) @ orientation / distance
            dir_factor = cos_theta
        return dir_factor
    
    def _compute_src_dir_factor(self, distance: float, mic_pos: np.ndarray, src_pos: np.ndarray, src_orientation: float) -> float:
        
        if self.src_dir_pattern == 'omnidirectional':
            dir_factor = 1
            return dir_factor
        
        if self.static_src:
            pos_variation_mod = 1
            cos_theta = (src_pos[:2] - mic_pos[:2]) @ np.array([1,0]) / distance
            theta = np.pi - np.arccos(cos_theta)
        # Compute modulus of vector from past src_pos to current src_pos (speed direction)
        else:
            pos_variation_mod = math.sqrt(np.sum((src_pos - self._prev_src_pos) ** 2))
        
            # Compute angle between direction of source velocity and mic-to-src direction using cosine law
            cos_theta = ((self._prev_src_dist ** 2 + pos_variation_mod ** 2 - distance ** 2) / (2 * self._prev_src_dist * pos_variation_mod))
            if abs(cos_theta) > 1:
                cos_theta = np.sign(cos_theta)
            
            theta= np.arccos(cos_theta)
            if ((src_pos[0] - self._prev_src_pos[0]) * (mic_pos[1] - self._prev_src_pos[1]) - (src_pos[1] - self._prev_src_pos[1]) * (mic_pos[0] - self._prev_src_pos[0]) < 0):
                theta = - theta

        # Add orientation angle to obtain actual orientation
        theta += src_orientation

        if self.src_dir_pattern == 'subcardioid':
            dir_factor = 0.75 + 0.25 * cos_theta
        elif self.src_dir_pattern == 'cardioid':
            dir_factor = 0.5 + 0.5 * cos_theta
        elif self.src_dir_pattern == 'supercardioid':
            dir_factor = 1/3 + 2/3 * cos_theta
        elif self.src_dir_pattern == 'hypercardioid':
            dir_factor = 0.25 + 0.75 * cos_theta
        elif self.src_dir_pattern == 'figure8':
            dir_factor = cos_theta
        return dir_factor
    
    def _compute_directivity_filter_table_road_tire(self, filt_taps: int = 11) -> Tuple[np.ndarray, np.ndarray]:
        '''
        Compute filters to implement vertical and horizontal directivity using FIR filters, in accordance to the equations
        proposed in the Harmonoise/Nordic2000 model.
        '''
        phi = np.linspace(0, 180, 181)
        psi = np.linspace(0, 90, 91)
        filt_coeffs_table = np.zeros((len(phi), len(psi), filt_taps))
        delta_L = np.zeros((len(phi), len(psi)))

        if self.fs < 16000:
            freq_bands = np.array([[0, 707], [707, self.fs/2]])
            gains = np.array([[0,1], [1,1]])
        else:
            freq_bands = np.array([[0, 707],[707,7127], [7127, self.fs/2]])
            gains =  np.array([[0,1], [1,1],[1,0]])

        for i in range(len(phi)):
            for j in range(len(psi)):
                delta_L[i,j] = (-2.5 + 4 * np.abs(np.cos(math.radians(phi[i])))) * np.cos(math.radians(psi[j]))
                filt_coeffs_table[i,j] = scipy.signal.firls(filt_taps, freq_bands, gains, fs=self.fs)

        return filt_coeffs_table, delta_L
    
    def _compute_directivity_filter_table_engine(self) -> Tuple[np.ndarray, np.ndarray]:
        '''
        Compute filters to implement vertical and horizontal directivity using FIR filters, in accordance to the equations
        proposed in the Harmonoise/Nordic2000 model.
        '''
        phi = np.linspace(0, 180, 181)
        psi = np.linspace(0, 90, 91)
        filt_coeffs_table = np.zeros((len(phi), len(psi)))
        delta_L = np.zeros((len(phi), len(psi)))

        for i in range(len(phi)):
            for j in range(len(psi)):
                delta_L[i,j] = (1.546 * (np.pi / 2 - math.radians(phi[i])) ** 3 
                                - 1.425 * (np.pi / 2 - math.radians(phi[i])) ** 2 
                                + 0.22*(np.pi/2 - math.radians(phi[i])) + 0.6) * np.sqrt(np.cos(math.radians(psi[j]))) 
                
        return filt_coeffs_table, delta_L

    def _precompute_complex_angle_reflection_filter_table(self):
        """
        Precompute the complex ground reflection coefficients and store in table for faster simulation
        """
        w_tmp = np.zeros_like(self._theta_vector)
        Rp = np.zeros_like(self._theta_vector)

        for i in range(len(self._theta_vector)):
            w_tmp = (1.0 + 1.0/self.Z * np.cos(math.radians(self._theta_vector[i])) - np.sqrt(1.0 - (1.0/self.Z) ** 2.0) * np.sin(math.radians(self._theta_vector[i])))
            Rp = (self.Z * np.cos(math.radians(self._theta_vector[i])) - 1.0)/(self.Z * np.cos(math.radians(self._theta_vector[i])) + 1.0) 
        return w_tmp, Rp

    def _get_asphalt_reflection_filter(self, theta: float, dist: float):
        if isinstance(self.road_material, int):
            # Complex case
            if np.abs(theta) >= 89:
                idx = np.where(self._theta_vector == np.sign(theta) * 89)
            else:
                idx = np.where(self._theta_vector == round(theta))
            idx = idx[0][0]
            
            w = np.sqrt(-1j * 2.0 * np.pi * self.f_tmp/343.0 * dist * self.w_tmp[idx])
            F_w = 1.0 - 1j * np.sqrt(np.pi) * w * scipy.special.erfcx(1j * w)
            Q = self.Rp + (1.0 - self.Rp) * F_w
            q = np.fft.irfft(Q)
            q = q[:40]
            return q
        
        elif isinstance(self.road_material, Material):
            # Real case
            if round(theta) == 90:
                theta = 89
            if round(theta) == -90:
                theta = -89
            idx = np.where(self._theta_vector == round(theta))
            
            idx = idx[0][0]
            
            return self.realAsphaltReflectionFilterTable[idx]