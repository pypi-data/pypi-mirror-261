# -*- coding: utf-8 -*-
"""
Created on Tue Jun  6 17:18:42 2023

@author: Laurent Foulloy
"""

from floulib.Defuzzify import Defuzzify
from floulib.Discrete import Discrete
from floulib.Multilinear import Multilinear
from floulib.Operator import Operator
from floulib.Plot import Plot
from floulib.Rule import Rule
from floulib.Variable import Variable
import numpy as np


class Rules(Plot):
    """
    This class contains methods to define and use a set of rules.
    
    .. note::
        
        Rules is a subclass of :class:`Plot`, therefore all methods 
        in :class:`Plot` may be used.    

    """    
    def __init__(self, *args):
        """
        Constructor

        Parameters
        ----------
        *args : Rule
            Arguments are instances of Rule.

        Raises
        ------
        TypeError
            If arguments are not instances of Rule.

        Returns
        -------
        None.
        
        Example
        -------
        >>> from floulib import Term, Triangle, Rule, Rules, Variable
        >>> import numpy as np
        >>> A1 = Term('A1', Triangle(0, 5, 10, label = '$A_1$'))
        >>> A2 = Term('A2', Triangle(5, 10, 15, label = '$A_2$'))
        >>> B1 = Term('B1', Triangle(0, 2, 4, label = '$B_1$'))
        >>> B2 = Term('B2', Triangle(2, 4, 6, label = '$B_2$'))        
        >>> v1 = Variable(np.linspace(0,15, 1000))
        >>> v2 = Variable(np.linspace(0, 10, 1000))
        >>> R = Rules(
            Rule().If(v1.Is(A1)).Then(v2.Is(B1)),
            Rule().If(v1.Is(A2)).Then(v2.Is(B2))
            )  
        
        Support of the relation generated by the rules (conjunctive representation).
        
        >>> R.plot(xlim = [-1, 16], ylim = [-1, 7])
        
        .. image:: images/Rules.__init___1.png  
        
        Support of the relation generated by the rules (implicative representation).
        
        >>> R.plot(xlim = [-1, 16], ylim = [-1, 7], implication = True)
        
        .. image:: images/Rules.__init___2.png   
        
        """
        for arg in args:
            if not isinstance(arg, Rule):
                raise TypeError('Arguments must be instance of Rule.')
        self._object = args       
        
        
   
    def inference(self, *args, **kwargs):
        """
        Computes the image of a fuzzy subsets by a set of rules.

        Parameters
        ----------
        *args : Variable
            Antecedents.
        **kwargs :  Operator
            - R: the implication operator. Default is :meth:`Operator.R_KD`.
            - T: the modus ponens triangular norm. Default is :meth:`Operator.T_Z`.
            - T1: the triangular norm to combine antecedents. Default is :meth:`Operator.T_Z`.

        Returns
        -------
        Discrete
            The result.
            
        Example
        -------
        >>> from floulib import Term, Triangle, Rule, Rules, Variable
        >>> import numpy as np
        >>> A1 = Term('A1', Triangle(0, 5, 10, label = '$A_1$'))
        >>> A2 = Term('A2', Triangle(5, 10, 15, label = '$A_2$'))
        >>> B1 = Term('B1', Triangle(0, 2, 4, label = '$B_1$'))
        >>> B2 = Term('B2', Triangle(2, 4, 6, label = '$B_2$'))        
        >>> v1 = Variable(np.linspace(0,15, 1000))
        >>> v2 = Variable(np.linspace(0, 10, 1000))
        >>> R = Rules(
            Rule().If(v1.Is(A1)).Then(v2.Is(B1)),
            Rule().If(v1.Is(A2)).Then(v2.Is(B2))
            )    
        >>> A = Triangle(6, 8, 9)             
        >>> B = R.inference(v1.Is(A)).label('$B$')
        >>> B.plot().add_plot(B1, alpha = 0.3).add_plot(B2, alpha = 0.3)
        
        .. image:: images/Rules.inference.png          
        """
        func = np.minimum
        if 'R' in kwargs:
            if kwargs['R'].__name__ in (Operator().R_M.__name__, Operator().R_P.__name__):
                if 'S' not in  kwargs:
                    func = Operator().S_Z 
                else:
                    func =  kwargs['S']
        # res = self._object[0].inference(*args, **kwargs)._object.points
        res = self._object[0].inference(*args, **kwargs).points        
        for i in range(1, len(self._object)):
            # res[:,1] = np.vectorize(func)(res[:,1], self._object[i].inference(*args, **kwargs)._object._memberships)
            res[:,1] = np.vectorize(func)(res[:,1], self._object[i].inference(*args, **kwargs)._memberships)
        return Discrete(*res)
    
 
    
    def sugeno_controller(self, *args):    
        """
        Computes the output of a Sugeno controller.

        Parameters
        ----------
        *args : Variable
            Arguments are instances of Variable.

        Raises
        ------
        Exception 
            If the length of If parts of the rules and number 
            of arguments are not the same.
        Exception 
            If the If parts of the rules are instances of Multilinear but 
            do not have universes associated with.            
        TypeError               
            If the If part of the rules are not instances of Variable.
        TypeError     
            Raised if the Then part of the rules is not instance of Variable. 

        Returns
        -------
        float
            The ouput of the Sugeno controller.
            
        Example
        -------
        >>> from floulib import Term, Triangle, Rule, Rules, Variable
        >>> import numpy as np
        >>> A1 = Term('A1', Triangle(0, 5, 10, label = '$A_1$'))
        >>> A2 = Term('A2', Triangle(5, 10, 15, label = '$A_2$'))
        >>> v1 = Variable(np.linspace(0,15, 1000))
        >>> v2 = Variable(np.linspace(0, 50, 1000))
        >>> R = Rules(
            Rule().If(v1.Is(A1)).Then(v2.Is(lambda x: x-3)),
            Rule().If(v1.Is(A2)).Then(v2.Is(lambda x: 3*x + 5))
            )
        >>> y = R.sugeno_controller(v1.Is(8))
        >>> print(y)
        19.4
        """
        # Verifications
        if len(args) != len(self._object[0]._ruleIf):
            raise Exception('Length of If parts and number of arguments must be the same.')
        for ifPart in self._object[0]._ruleIf:
            if not isinstance(ifPart, Variable):
                raise TypeError('Variables in the If part must be instances of Variable.')  
            elif isinstance(ifPart._object, Multilinear) and  ifPart._object._universe is None:
                raise Exception('Variables in the If part must have a universe.')
        if not isinstance(self._object[0]._ruleThen, Variable):
            raise TypeError('Variable in the Then part must be an instance of Variable.')             
        
        res = self._object[0]._sugeno_controller(*args)
        for i in range(1, len(self._object)):
            res = res | self._object[i]._sugeno_controller(*args)
        return Defuzzify().numeric(res)

        

    ###
    # Private methods
    #   
    
    def _support(self, implication):
        P = self._object[0]._support(implication) 
        for i in range(1, len(self._object)):
            if implication:
                P = P.intersection(self._object[i]._support(implication))
            else:
                P = P.union(self._object[i]._support(implication))
        return P        