# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['P', 'intfloatq', 'CoordFormat', 'SliceFormat', 'SliceFormats', 'nans', 'nanslike', 'flip_slice_format',
           'match_slice_format', 'guess_slice_format', 'to_slice_format', 'sdim', 'makeslcs', 'slcten', 'setslcs',
           'slcswith', 'slcloc', 'slcval', 'Slice']

# %% ../nbs/00_core.ipynb 6
from dataclasses import dataclass, field

# %% ../nbs/00_core.ipynb 8
from typing import TypeAlias, Literal, Union, ParamSpec


# %% ../nbs/00_core.ipynb 10
try: import torch
except: ...

try: import numpy as np
except: ...

try: import pandas as pd
except: ...

# %% ../nbs/00_core.ipynb 12
from nlit import (
    COORD, SLICE, 
    START, STOP, STEP, 
    NUMPY, PANDAS, DICT, LIST, TUPLE,
)
from quac import axesidxsq, num, ints, intq, strq, slicespecs, tensor, booltensor, nantensor, nparray, series
from chck import notnone, isnone, isiter, isslice
from sigr import applyfns
from asto import asslc

# %% ../nbs/00_core.ipynb 14
#| export


# %% ../nbs/00_core.ipynb 17
P = ParamSpec('P')

intfloatq : TypeAlias = int | float | None

CoordFormat: TypeAlias = Literal['coord'];
SliceFormat: TypeAlias = Literal['slice'];
SliceFormats: TypeAlias = Union[CoordFormat, SliceFormat]

# %% ../nbs/00_core.ipynb 19
def nans(size: tuple) -> nantensor:
    '''
    Create a tensor of `size` filled with `torch.nan`

    Parameters
    ----------
    size : tuple
        The size of the tensor to be created.

    Returns
    -------
    NanTensor
        A tensor of the specified size filled with NaN values.
    '''
    return torch.nan * torch.zeros(size)

def nanslike(t: tensor) -> nantensor: 
    '''
    Create a tensor of the same size as the given tensor, filled with NaN values.

    Parameters
    ----------
    t : Tensor
        The tensor to match the size of.

    Returns
    -------
    NanTensor
        A tensor of the same size as `t`, filled with NaN values.
    '''
    return nans(t.shape)

# %% ../nbs/00_core.ipynb 21
def flip_slice_format(*slcs: slicespecs) -> slicespecs:
    '''
    Flips the format of the given slices between 'coord' and 'slice'.

    Parameters
    ----------
    slcs : Slcs
        The slices to flip. Can be in 'coord' or 'slice' format.

    Returns
    -------
    Slcs
        The slices flipped to the opposite format.

    Examples
    --------
    >>> flip_slice_format((0, 10), (0, 10))
    ((0, 0), (10, 10))
    '''
    return tuple(zip(*slcs))

def match_slice_format(fmt: str) -> SliceFormats:
    '''Matches the given format to the closest valid format.
    Parameters
    ----------
    fmt : str
        The format to match.
    
    Returns
    -------
    fmt : {`'coord'`, `'slice'`}
        The matched slice format.
    '''
    match fmt:
        case 'coord': return COORD
        case 'slice': return SLICE
        case _: return SLICE
        

def guess_slice_format(*slcs: slicespecs) -> slicespecs:
    '''Guesses the slice format based on the given slices.

    Parameters
    ----------
    slcs : slicespecs
        The slices to evaluate.

    Returns
    -------
    fmt : {`'coord'`, `'slice'`}
        The guessed slice format.

    Examples
    --------
    >>> guess_slice_format((0, 10), (0, 10))
    'slice'
    '''
    if any(isslice(slc) for slc in slcs): return SLICE
    if any([len(slc) > 3 for slc in slcs]): return COORD
    return SLICE

# %% ../nbs/00_core.ipynb 22
def to_slice_format(*slcs: slicespecs, fmt: str, cur: strq = None):
    fmt = match_slice_format(fmt)
    if isnone(cur): cur = guess_slice_format(*slcs)
    if cur == fmt: return slcs
    else: return flip_slice_format(*slcs)

# %% ../nbs/00_core.ipynb 24
def sdim(*slcs: slicespecs, axes: ints = None, ndim: intq = None) -> int:
     '''
     Calculate the number of dimensions to which the slices apply.

     Parameters
     ----------
     slcs : Slcs
          The slices for which the dimensionality is to be determined.

     axes : tuple[int, ...], optional
          The axes that the slices apply to, defaults to None.

     ndim : int, optional
          The number of dimensions of the target tensor, defaults to None.

     Returns
     -------
     int
          The number of dimensions to which the slices apply.

     Examples
     --------
     >>> sdim((0, 10), (0, 10))
     2
     '''
     if notnone(ndim): return ndim
     if isnone(axes): return len(slcs)
     if isiter(axes): return max(max(axes) + 1, len(axes))
     return axes

# %% ../nbs/00_core.ipynb 26
def makeslcs(
    *slcs: slicespecs, 
    axes: ints = None, 
    ndim: intq = None, 
    fmt: SliceFormats = SliceFormat,
) -> list[slice]:     
    '''
    Convert tuples representing slices into actual Python slice objects.

    Parameters
    ----------
    slcs : Slcs
        Tuples representing the slices.
        
    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.

    ndim : int, optional
        The number of dimensions of the target tensor, defaults to None.

    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    Returns
    -------
    list[slice]
        A list of Python slice objects.

    Examples
    --------
    >>> makeslcs((0, 10), (0, 10))
    [slice(0, 10, None), slice(0, 10, None)]
    '''
    # (x0, y0), (x1, y1) --> (x0, x1), (y0, y1)
    if isnone(fmt): fmt = guess_slice_format(*slcs)
    if fmt == SliceFormat.coord: slcs = flip_slice_format(*slcs)

    # Convert slcs tuples into slices
    slices = list(asslc(slc, __nones_ok=True) for slc in slcs)
    nslice = sdim(*slices, axes=axes, ndim=ndim)
    
    # Create a list of slice(None) for all dimensions
    axes = list([slice(None)] * nslice if isnone(axes) else axes)

    # Replace slices for specified axes
    slices = [slices[axes.index(i)] if i in axes else slice(None) for i in range(nslice)]
    return slices

# %% ../nbs/00_core.ipynb 28
def slcten(
    tens: tensor,
    *slcs: slicespecs, 
    axes: ints = None, 
    fmt: SliceFormats = SliceFormat,
    inplace: bool = True, 
    __setval: tuple = None, 
    __retsub: bool = True
) -> tensor:
    '''
    Extract or modify a subslice of a tensor based on provided slice specifications.

    Parameters
    ----------
    tens : Tensor
        The tensor to slice or modify.
        
    slcs : Slcs
        Tuples representing the slices.
        
    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.
        
    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.
        
    inplace : bool, default: True
        If True, modify the tensor in place, defaults to True.
        
    __setval : tuple, optional
        The value to set the sliced region to, defaults to None.
        
    __retsub : bool, default: True
        If True, return the sliced part of the tensor, defaults to True.

    Returns
    -------
    Tensor
        The modified or extracted part of the tensor.

    Examples
    --------
    >>> slcten(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,))
    tensor([[1, 2]])
    '''
    if isnone(axes): axes = (0, 1) if tens.ndim <= 3 else (1, 2)    
    slcs = makeslcs(*slcs, axes=axes, ndim=tens.ndim, fmt=fmt)
    tout = tens[slcs] if __retsub else tens
    
    if notnone(__setval) and __retsub:
        return torch.ones_like(tout) * torch.tensor(__setval)
    
    tout = tens.clone() if not inplace else tout
    if notnone(__setval):
        tout[slcs] = torch.tensor(__setval)
        return tout
    return tout

# %% ../nbs/00_core.ipynb 30
def setslcs(
    ten: tensor, 
    *slcs: slicespecs, 
    axes: axesidxsq = None, 
    fmt: SliceFormats = SliceFormat,
    val: tuple = torch.nan, 
    inplace: bool = False
) -> tensor:
    '''
    Apply a mask to a tensor (i.e. set `value` to the specified slices).

    Parameters
    ----------
    ten : Tensor
        The tensor to modify.

    slcs : Slcs
        Tuples representing the slices.

    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.

    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    val : tuple | nan, default: torch.nan
        The value to apply to the slices, defaults to NaN.
        
    inplace : bool, default: False
        If True, modify the tensor in place, defaults to False.

    Returns
    -------
    Tensor
        The modified tensor.

    Examples
    --------
    >>> setslcs(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,), val=0)
    tensor([[0, 0], [3, 4]])
    '''
    return slcten(ten, *slcs, axes=axes, fmt=fmt, inplace=inplace, __setval=val, __retsub=False)

# %% ../nbs/00_core.ipynb 32
def slcswith( 
     *slcs: slicespecs, 
     size: ints = (400, 400, 3), 
     axes: axesidxsq = None,
     fmt: SliceFormats = SliceFormat, 
     val: tuple = torch.nan, 
     ttype: num | type = torch.nan,
) -> tensor:
    '''
    Create a tensor of a specified size, applying a value to specified slices.
    
    Parameters
    ----------
    slcs : Slcs
        Tuples representing the slices.

    size : tuple[ints, ...], default: (400, 400, 3)
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.

    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    val : tuple | nan, default: torch.nan
        The value to apply to the slices, defaults to NaN.
        
    ttype : num | type, default: torch.nan
        The type of tensor to create, defaults to NaN.

    Returns
    -------
    Tensor
        The created tensor with the specified slices modified.

    Examples
    --------
    >>> slcswith((0, 100), (0, 100), size=(200, 200), val=1)
    # Returns a 200x200 tensor with the top-left 100x100 block set to 1

    Notes
    -----
    - meant to represent "sliced with"
    '''
    tfunc = torch.zeros
    if ttype == torch.nan:   tfunc = nans
    if ttype == torch.bool:  tfunc = torch.ones
    if ttype == torch.zeros: tfunc = nans

    return setslcs(tfunc(size), *slcs, axes=axes, fmt=fmt, val=val, inplace=True)     

# %% ../nbs/00_core.ipynb 34
def slcloc(
    *slcs: slicespecs, 
    size: ints = (400, 400, 3), 
    axes: axesidxsq = None,
    fmt: SliceFormats = SliceFormat,
) -> booltensor:
    '''
    Convert slices to a boolean index tensor for a tensor of a given `size`.

    Parameters
    ----------
    slcs : Slcs
        Tuples representing the slices.

    size : ints, default: (400, 400, 3)
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.
        
    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    Returns
    -------
    BoolTensor
        A boolean tensor indicating the locations of the slices.

    Examples
    --------
    >>> slcloc((0, 100), (0, 100), size=(200, 200))
    # Returns a 200x200 boolean tensor with True in the top-left 100x100 block
    '''
    tens = slcswith(*slcs, size=size, axes=axes, fmt=fmt, val=torch.nan, ttype=torch.zeros)     
    return tens.isnan() 

# %% ../nbs/00_core.ipynb 36
def slcval(
    *slcs: slicespecs, 
    size: ints = (400, 400, 3), 
    axes: ints = (0, 1), 
    fmt: SliceFormats = SliceFormat, 
    val: tuple = torch.nan,
) -> tensor:
    '''
    Create a `tensor` of a specified `size`, applying a `value` only to specified `slices`.

    Parameters
    ----------
    slcs : Slcs
        Tuples representing the slices.

    size : ints, default: (400, 400, 3)
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : tuple[int, ...], default: (0, 1)
        The axes that the slices apply to, defaults to (0, 1).

    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.
        
    val : tuple | nan, default: torch.nan
        The value to apply to the slices, defaults to NaN.

    Returns
    -------
    Tensor
        The created tensor with the specified value applied to the slices.

    Examples
    --------
    >>> slcval((0, 100), (0, 100), size=(200, 200), val=1)
    # Returns a 200x200 tensor with the top-left 100x100 block set to 1
    '''
    return slcswith(*slcs, size=size, axes=axes, fmt=fmt, val=val, ttype=torch.nan)     

# %% ../nbs/00_core.ipynb 38
@dataclass
class Slice:
    '''A class for representing a slice and providing conversion to other formats.'''
    slc: slice = field(default_factory=slice)

    @property
    def start(self) -> int:
        try: return self._start
        except AttributeError: self._start = self.slc.start
        return self._start
    
    @start.setter
    def start(self, value):
        '''Sets the start index.'''
        if value < 0: raise ValueError('Slice indices must be non-negative.')
        self._start = value

    @property
    def stop(self) -> int:
        try: return self._stop
        except AttributeError: self._stop = self.slc.stop
        return self._stop
    
    @stop.setter
    def stop(self, value):
        '''Sets the stop index.'''
        if value < 0:
            raise ValueError('Slice indices must be non-negative.')
        self._stop = value
    
    @property
    def step(self) -> int:
        '''Gets the step index.'''
        try: return self._step
        except AttributeError: self._step = self.slc.step
        return self._step
    
    @step.setter
    def step(self, value):
        '''Sets the step index.'''
        if value < 0: raise ValueError('Slice step must be non-negative.')
        self._step = value
    
    def __post_init__(self):
        if self.start is None:
            self.start = 0

        if self.stop is None:
            self.stop = min(0, self.start, max(1, self.start))

        if self.step is None:
            self.step = 1

    def totuple(self) -> tuple[intfloatq, intfloatq, intfloatq]:
        '''Converts the slice to a tuple.'''
        return (self.start, self.stop, self.step)
    
    def toslice(self) -> slice:
        '''Converts the updated slice.'''
        return slice(self.start, self.stop, self.step)
    
    def tolist(self) -> list[int | float]:
        '''Converts the slice to a list.'''
        return list(range(self.start, self.stop, self.step))
    
    def todict(self) -> list[int | float]:
        '''Converts the slice to a dict.'''
        return dict(zip('start stop step'.split(), self.totuple()))
        
    def astype(self, dtype:str):
        '''Converts the slice to a specified format.'''
        if dtype in {LIST, list}:
            return self.tolist()
        elif dtype in {NUMPY, nparray}:
            try: import numpy as np
            except: ...
            return np.array(self.tolist())
        elif dtype in {PANDAS, series}:
            try: import pandas as pd
            except: ...
            return pd.Series(self.tolist())
        elif dtype in {TUPLE, tuple}:
            return self.totuple()
        elif dtype in {DICT, dict}:
            return self.todict()
        elif dtype in {SLICE, slice}:
            return self.toslice()
        return self

# %% ../nbs/00_core.ipynb 40
#| export
