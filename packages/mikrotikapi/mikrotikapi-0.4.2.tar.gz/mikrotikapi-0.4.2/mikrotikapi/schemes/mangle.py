from pydantic import (    BaseModel,    Field,    ConfigDict,    field_serializer,    field_validator,)from mikrotikapi.schemes.components import Action, ToPorts, ToAddressesfrom mikrotikapi.schemes.fields import (    comment_field,    id_field,    field_gen,    bytes_field,    log_prefix_field,)from mikrotikapi.schemes.fields.protocol import ProtocolControllerfrom mikrotikapi.schemes.groups import (    AddressMatchGroup,    InterfaceGroup,    InterfaceListGroup,    MarkGroup,)from mikrotikapi.utils.api_path import api_pathallowed_protos = [    ProtocolController.tcp,    ProtocolController.udp,    ProtocolController.udp_lite,    ProtocolController.dccp,    ProtocolController.sctp,]# chain change default valueclass MangleScheme(    ToPorts,    Action,    AddressMatchGroup,    ToAddresses,    InterfaceGroup,    InterfaceListGroup,    MarkGroup,    BaseModel,):    id: str = id_field    bytes: int = bytes_field    disabled: bool = Field(False)    dst_port: int = field_gen(None, name="dst_port")    disable: bool = Field(None, exclude=True)    dynamic: bool = Field(None, exclude=True)    invalid: bool = Field(None, exclude=True)    comment: str = comment_field    packets: int = Field(None, frozen=True, exclude=True)    log: bool = Field(False)    log_prefix: str = log_prefix_field    new_routing_mark: str = field_gen(None, name="new_routing_mark")    @field_validator("to_ports")    def check_to_ports(cls, to_ports, values):        protocol = values.data["protocol"]        if to_ports and (protocol not in allowed_protos):            raise ValueError(                f"to_ports cannot be set when protocol is {protocol}"            )        return to_ports    @field_serializer("disabled")    def serialize_disabled(self, v: list, _info):        return str(v).lower()    @field_serializer("log")    def serialize_log(self, v: list, _info):        return str(v).lower()    @field_serializer("dst_port")    def serialize_dst_port(self, v: list, _info):        return str(v)    @property    def tariff(self) -> str | None:        try:            return f"{self.comment.split(':')[0]}"        except AttributeError:            return None    # @computed_field    @property    def profile_id_validate(self) -> int | None:        try:            return int(self.comment.split(":")[1])        except (AttributeError, ValueError, IndexError):            return None    @property    def comment_value_0(self) -> str | None:        try:            return self.comment.split(":")[0]        except (AttributeError, IndexError):            return None    @property    def comment_value_1(self) -> str | None:        try:            return self.comment.split(":")[1]        except (AttributeError, IndexError):            return None    @property    def comment_value_2(self) -> str | None:        try:            return self.comment.split(":")[2]        except (AttributeError, IndexError):            return None    @staticmethod    def api_path(id_=None):        return api_path("/rest/ip/firewall/mangle", id_)    model_config = ConfigDict(populate_by_name=True)