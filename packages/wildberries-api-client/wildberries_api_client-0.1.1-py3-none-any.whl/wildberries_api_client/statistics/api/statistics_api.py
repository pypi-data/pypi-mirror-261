# coding: utf-8

"""
    Statistics

    Methods to get different reports. For Paid storage report, send a request to generate it, and then a request to get it. other report are available immediately, without pre-generation.   # noqa: E501

    OpenAPI spec version: 2.18
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from wildberries_api_client.statistics.api_client import ApiClient


class StatisticsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def api_v1_supplier_incomes_get(self, date_from, **kwargs):  # noqa: E501
        """Supplies  # noqa: E501

        Supplies. Maximum 1 request per minute  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v1_supplier_incomes_get(date_from, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str date_from: Date and time of last change on the supplie.<br> Date format: RFC3339. You may send date or date with time.  Time could be specified in seconds or milliseconds.<br> The time stands in Moscow time zone (UTC+3). <br>Examples: <ul> <li> `2019-06-20` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul>  (required)
        :return: list[IncomesItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v1_supplier_incomes_get_with_http_info(date_from, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v1_supplier_incomes_get_with_http_info(date_from, **kwargs)  # noqa: E501
            return data

    def api_v1_supplier_incomes_get_with_http_info(self, date_from, **kwargs):  # noqa: E501
        """Supplies  # noqa: E501

        Supplies. Maximum 1 request per minute  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v1_supplier_incomes_get_with_http_info(date_from, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str date_from: Date and time of last change on the supplie.<br> Date format: RFC3339. You may send date or date with time.  Time could be specified in seconds or milliseconds.<br> The time stands in Moscow time zone (UTC+3). <br>Examples: <ul> <li> `2019-06-20` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul>  (required)
        :return: list[IncomesItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['date_from']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_supplier_incomes_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'date_from' is set
        if ('date_from' not in params or
                params['date_from'] is None):
            raise ValueError("Missing the required parameter `date_from` when calling `api_v1_supplier_incomes_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'date_from' in params:
            query_params.append(('dateFrom', params['date_from']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/supplier/incomes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncomesItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v1_supplier_orders_get(self, date_from, **kwargs):  # noqa: E501
        """Orders  # noqa: E501

        Orders. <br>  Important: storage of data for orders is guaranteed for no more than 90 days from the date of order. The data is updated every 30 minutes.  The exact time when information was updated in the service can be seen in the `lastChangeDate` field. <br> To identify goods from one order, as well as sales on them, you should use the `gNumber` field (lines with the same value of this field refer to one order) and the number of the unique item in the order, the `odid` (`rid`) field.  Maximum 1 request per minute   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v1_supplier_orders_get(date_from, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str date_from: Date and time of last change on the order.<br> Date format: RFC3339. You may send date or date with time.  Time could be specified in seconds or milliseconds.<br> The time stands in Moscow time zone (UTC+3). <br>Examples: <ul> <li> `2019-06-20` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul>  (required)
        :param int flag: If parameter `flag=0` (or it doesn't exist in requests string), then call of API methods returns data,  which value of field `lastChangeDate` (date and time of refreshing info of service) is greater or equal to the given parameter value  `dateFrom`.  In this case the number of returned rows of data varies from 0 to approximately 100,000. <br> If parameter `flag=1`, then information about all orders or sales with the date will be uploaded,  that equals to the passed parameter `dateFrom` (in this case the time in the date doesn't matter).  Also the number of returned rows of data will be equal to the number of all orders or sales that were made on the specified date, passed in the `dateFrom` parameter. 
        :return: list[OrdersItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v1_supplier_orders_get_with_http_info(date_from, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v1_supplier_orders_get_with_http_info(date_from, **kwargs)  # noqa: E501
            return data

    def api_v1_supplier_orders_get_with_http_info(self, date_from, **kwargs):  # noqa: E501
        """Orders  # noqa: E501

        Orders. <br>  Important: storage of data for orders is guaranteed for no more than 90 days from the date of order. The data is updated every 30 minutes.  The exact time when information was updated in the service can be seen in the `lastChangeDate` field. <br> To identify goods from one order, as well as sales on them, you should use the `gNumber` field (lines with the same value of this field refer to one order) and the number of the unique item in the order, the `odid` (`rid`) field.  Maximum 1 request per minute   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v1_supplier_orders_get_with_http_info(date_from, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str date_from: Date and time of last change on the order.<br> Date format: RFC3339. You may send date or date with time.  Time could be specified in seconds or milliseconds.<br> The time stands in Moscow time zone (UTC+3). <br>Examples: <ul> <li> `2019-06-20` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul>  (required)
        :param int flag: If parameter `flag=0` (or it doesn't exist in requests string), then call of API methods returns data,  which value of field `lastChangeDate` (date and time of refreshing info of service) is greater or equal to the given parameter value  `dateFrom`.  In this case the number of returned rows of data varies from 0 to approximately 100,000. <br> If parameter `flag=1`, then information about all orders or sales with the date will be uploaded,  that equals to the passed parameter `dateFrom` (in this case the time in the date doesn't matter).  Also the number of returned rows of data will be equal to the number of all orders or sales that were made on the specified date, passed in the `dateFrom` parameter. 
        :return: list[OrdersItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['date_from', 'flag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_supplier_orders_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'date_from' is set
        if ('date_from' not in params or
                params['date_from'] is None):
            raise ValueError("Missing the required parameter `date_from` when calling `api_v1_supplier_orders_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'date_from' in params:
            query_params.append(('dateFrom', params['date_from']))  # noqa: E501
        if 'flag' in params:
            query_params.append(('flag', params['flag']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/supplier/orders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[OrdersItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v1_supplier_report_detail_by_period_get(self, date_from, date_to, **kwargs):  # noqa: E501
        """Realization sales report  # noqa: E501

        Details to the realization report.  <br> The report contains data for the last 3 months. <br> If there is no data for the specified period, the method will return `null`. <br> Technical break in the work of the method: every Monday from 3:00 AM to 4:00 PM. <br> <a href=\"../../excel_save/en/index.html\">Manual: Save statistics by Excel</a><br> Maximum 1 request per minute   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v1_supplier_report_detail_by_period_get(date_from, date_to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str date_from: Starting date of the report.<br>  Date format: RFC3339. You may send date or date with time.  Time could be specified in seconds or milliseconds.<br> The time stands in Moscow time zone (UTC+3). <br>Examples: <ul> <li> `2019-06-20` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul>  (required)
        :param date date_to: Report end date (required)
        :param int limit: The maximum number of report rows returned by the method. Cannot be more than 100000.
        :param int rrdid: The unique ID of the report line. Required to receive the report in parts. <br> Report loading must start with `rrdid = 0` and on subsequent API calls, pass the `rrd_id` value in the request from the row line received as a result of the previous call.  <br> Thus, to load a single report, you may need to call the API until the number of rows returned is zero. 
        :return: list[DetailReportItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v1_supplier_report_detail_by_period_get_with_http_info(date_from, date_to, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v1_supplier_report_detail_by_period_get_with_http_info(date_from, date_to, **kwargs)  # noqa: E501
            return data

    def api_v1_supplier_report_detail_by_period_get_with_http_info(self, date_from, date_to, **kwargs):  # noqa: E501
        """Realization sales report  # noqa: E501

        Details to the realization report.  <br> The report contains data for the last 3 months. <br> If there is no data for the specified period, the method will return `null`. <br> Technical break in the work of the method: every Monday from 3:00 AM to 4:00 PM. <br> <a href=\"../../excel_save/en/index.html\">Manual: Save statistics by Excel</a><br> Maximum 1 request per minute   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v1_supplier_report_detail_by_period_get_with_http_info(date_from, date_to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str date_from: Starting date of the report.<br>  Date format: RFC3339. You may send date or date with time.  Time could be specified in seconds or milliseconds.<br> The time stands in Moscow time zone (UTC+3). <br>Examples: <ul> <li> `2019-06-20` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul>  (required)
        :param date date_to: Report end date (required)
        :param int limit: The maximum number of report rows returned by the method. Cannot be more than 100000.
        :param int rrdid: The unique ID of the report line. Required to receive the report in parts. <br> Report loading must start with `rrdid = 0` and on subsequent API calls, pass the `rrd_id` value in the request from the row line received as a result of the previous call.  <br> Thus, to load a single report, you may need to call the API until the number of rows returned is zero. 
        :return: list[DetailReportItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['date_from', 'date_to', 'limit', 'rrdid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_supplier_report_detail_by_period_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'date_from' is set
        if ('date_from' not in params or
                params['date_from'] is None):
            raise ValueError("Missing the required parameter `date_from` when calling `api_v1_supplier_report_detail_by_period_get`")  # noqa: E501
        # verify the required parameter 'date_to' is set
        if ('date_to' not in params or
                params['date_to'] is None):
            raise ValueError("Missing the required parameter `date_to` when calling `api_v1_supplier_report_detail_by_period_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'date_from' in params:
            query_params.append(('dateFrom', params['date_from']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'date_to' in params:
            query_params.append(('dateTo', params['date_to']))  # noqa: E501
        if 'rrdid' in params:
            query_params.append(('rrdid', params['rrdid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/supplier/reportDetailByPeriod', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DetailReportItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v1_supplier_sales_get(self, date_from, **kwargs):  # noqa: E501
        """Sales  # noqa: E501

        Sales and returns. <br> Data storage is guaranteed for no more than 90 days from the date of sale. <br> The data updated every 30 minutes. <br> The `srid` field should be used to identify the order. <br> 1 line means 1 sale/return and means 1 item.  <br> Maximum 1 request per minute   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v1_supplier_sales_get(date_from, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str date_from: Date and time of last change on the sale/return.<br> Date format: RFC3339. You may send date or date with time.  Time could be specified in seconds or milliseconds.<br> The time stands in Moscow time zone (UTC+3). <br>Examples: <ul> <li> `2019-06-20` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul>  (required)
        :param int flag: If parameter `flag=0` (or it doesn't exist in requests string), then call of API methods returns data,  which value of field `lastChangeDate` (date and time of refreshing info of service) is greater or equal to the given parameter value  `dateFrom`.  In this case the number of returned rows of data varies from 0 to approximately 100,000. <br> If parameter `flag=1`, then information about all orders or sales with the date will be uploaded,  that equals to the passed parameter `dateFrom` (in this case the time in the date doesn't matter).  Also the number of returned rows of data will be equal to the number of all orders or sales that were made on the specified date, passed in the `dateFrom` parameter. 
        :return: list[SalesItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v1_supplier_sales_get_with_http_info(date_from, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v1_supplier_sales_get_with_http_info(date_from, **kwargs)  # noqa: E501
            return data

    def api_v1_supplier_sales_get_with_http_info(self, date_from, **kwargs):  # noqa: E501
        """Sales  # noqa: E501

        Sales and returns. <br> Data storage is guaranteed for no more than 90 days from the date of sale. <br> The data updated every 30 minutes. <br> The `srid` field should be used to identify the order. <br> 1 line means 1 sale/return and means 1 item.  <br> Maximum 1 request per minute   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v1_supplier_sales_get_with_http_info(date_from, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str date_from: Date and time of last change on the sale/return.<br> Date format: RFC3339. You may send date or date with time.  Time could be specified in seconds or milliseconds.<br> The time stands in Moscow time zone (UTC+3). <br>Examples: <ul> <li> `2019-06-20` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul>  (required)
        :param int flag: If parameter `flag=0` (or it doesn't exist in requests string), then call of API methods returns data,  which value of field `lastChangeDate` (date and time of refreshing info of service) is greater or equal to the given parameter value  `dateFrom`.  In this case the number of returned rows of data varies from 0 to approximately 100,000. <br> If parameter `flag=1`, then information about all orders or sales with the date will be uploaded,  that equals to the passed parameter `dateFrom` (in this case the time in the date doesn't matter).  Also the number of returned rows of data will be equal to the number of all orders or sales that were made on the specified date, passed in the `dateFrom` parameter. 
        :return: list[SalesItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['date_from', 'flag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_supplier_sales_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'date_from' is set
        if ('date_from' not in params or
                params['date_from'] is None):
            raise ValueError("Missing the required parameter `date_from` when calling `api_v1_supplier_sales_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'date_from' in params:
            query_params.append(('dateFrom', params['date_from']))  # noqa: E501
        if 'flag' in params:
            query_params.append(('flag', params['flag']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/supplier/sales', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SalesItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v1_supplier_stocks_get(self, date_from, **kwargs):  # noqa: E501
        """Warehouse  # noqa: E501

        WB stock product leftover. The data is updated every 30 minutes.  The statistics service does not keep a history of product leftovers, so you can only retrieve data about them in 'real time' mode. Maximum 1 request per minute   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v1_supplier_stocks_get(date_from, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str date_from: Date and time of last change on the product.<br> The earliest possible value should be entered to get the total leftover, e.g. `2019-06-20`. Date format: RFC3339. You may send date or date with time.  Time could be specified in seconds or milliseconds.<br> The time stands in Moscow time zone (UTC+3). <br>Examples: <ul> <li> `2019-06-20` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul>  (required)
        :return: list[StocksItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v1_supplier_stocks_get_with_http_info(date_from, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v1_supplier_stocks_get_with_http_info(date_from, **kwargs)  # noqa: E501
            return data

    def api_v1_supplier_stocks_get_with_http_info(self, date_from, **kwargs):  # noqa: E501
        """Warehouse  # noqa: E501

        WB stock product leftover. The data is updated every 30 minutes.  The statistics service does not keep a history of product leftovers, so you can only retrieve data about them in 'real time' mode. Maximum 1 request per minute   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v1_supplier_stocks_get_with_http_info(date_from, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str date_from: Date and time of last change on the product.<br> The earliest possible value should be entered to get the total leftover, e.g. `2019-06-20`. Date format: RFC3339. You may send date or date with time.  Time could be specified in seconds or milliseconds.<br> The time stands in Moscow time zone (UTC+3). <br>Examples: <ul> <li> `2019-06-20` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul>  (required)
        :return: list[StocksItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['date_from']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_supplier_stocks_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'date_from' is set
        if ('date_from' not in params or
                params['date_from'] is None):
            raise ValueError("Missing the required parameter `date_from` when calling `api_v1_supplier_stocks_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'date_from' in params:
            query_params.append(('dateFrom', params['date_from']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/supplier/stocks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StocksItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
