# coding: utf-8

"""
    Seller API Content

    Queries limits: <dd>Maximum of 100 requests per minute to all Content methods are allowed.</dd> <br> Public API for Content is designed for server-to-server data synchronization between Wildberries and Suppliers. <br> You download data from Wildberries to your computing resources for further operating it. <br> <code>It is not allowed to use the Content API as an external database. If you exceed the requests limits, access to the API will be restricted.</code> <br> <br> <br>   # noqa: E501

    OpenAPI spec version: 2.18
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from content.api_client import ApiClient


class UploadApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def content_v2_barcodes_post(self, body, **kwargs):  # noqa: E501
        """Generation of barcodes  # noqa: E501

        Generates array of unique barcodes to create size of nomenclature in product card.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.content_v2_barcodes_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2BarcodesBody body: (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.content_v2_barcodes_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.content_v2_barcodes_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def content_v2_barcodes_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Generation of barcodes  # noqa: E501

        Generates array of unique barcodes to create size of nomenclature in product card.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.content_v2_barcodes_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2BarcodesBody body: (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_v2_barcodes_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `content_v2_barcodes_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/content/v2/barcodes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_v2_cards_move_nm_post(self, **kwargs):  # noqa: E501
        """Merging or separating of nomenclatures  # noqa: E501

        Merges nomenclatures (`nmID`) in same product card (`imtID`) or separate them.<br>  To merge nomenclatures, the request with a list of nomenclatures has to be sent with the `targetIMT` parameter specified in the body of the request. In this case, all nomenclatures will be merged under the `imtID` specified in the `targetIMT`.<br> <br> To separate the nomenclature from the product card, it is necessary to pass this nomenclature without the `targetIMT` parameter in the request body.<br> This creates a new `imtID` for the transferred nomenclature.<br> If several nomenclatures are passed in the <b>separating</b> request, they will all be automatically <b>merged</b> under one new `imtID`.<br> To assign a unique `imtID` to each nomenclature, it is necessary to send one nomenclature per query. For nomenclatures that are not transferred in the request, no changes will be made.<br> <br> <b>Important.</b> It is possible to merge nomenclatures containing only the same items.<br> <b>Important.</b> One product card (inside one `imtID`) cannot contain more than 30 nomenclatures (`nmID`).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.content_v2_cards_move_nm_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CardsMoveNmBody body:
        :return: ResponseCardCreate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.content_v2_cards_move_nm_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.content_v2_cards_move_nm_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def content_v2_cards_move_nm_post_with_http_info(self, **kwargs):  # noqa: E501
        """Merging or separating of nomenclatures  # noqa: E501

        Merges nomenclatures (`nmID`) in same product card (`imtID`) or separate them.<br>  To merge nomenclatures, the request with a list of nomenclatures has to be sent with the `targetIMT` parameter specified in the body of the request. In this case, all nomenclatures will be merged under the `imtID` specified in the `targetIMT`.<br> <br> To separate the nomenclature from the product card, it is necessary to pass this nomenclature without the `targetIMT` parameter in the request body.<br> This creates a new `imtID` for the transferred nomenclature.<br> If several nomenclatures are passed in the <b>separating</b> request, they will all be automatically <b>merged</b> under one new `imtID`.<br> To assign a unique `imtID` to each nomenclature, it is necessary to send one nomenclature per query. For nomenclatures that are not transferred in the request, no changes will be made.<br> <br> <b>Important.</b> It is possible to merge nomenclatures containing only the same items.<br> <b>Important.</b> One product card (inside one `imtID`) cannot contain more than 30 nomenclatures (`nmID`).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.content_v2_cards_move_nm_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CardsMoveNmBody body:
        :return: ResponseCardCreate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_v2_cards_move_nm_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/content/v2/cards/moveNm', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResponseCardCreate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_v2_cards_update_post(self, body, **kwargs):  # noqa: E501
        """Update a card  # noqa: E501

        Edits product cards. If you need some product data, get it using <a href=\"./#tag/View/paths/~1content~1v1~1cards~1cursor~1list/post\">Nomenclature list method</a>.  You can not edit or delete barcodes but you can add new ones. You have not to send `photos`, `video` and `tags` and can not edit them.  If this method response is Success (200) but product card was not updated, check errors using <a href=\"./#tag/View/paths/~1content~1v1~1cards~1error~1list/get\">List of failed nomenclature with errors</a> method. Correct the request and try again.  With one request you can edit maximum 100 nomenclatures (`nmID`).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.content_v2_cards_update_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[CardsUpdateBody] body: (required)
        :return: ResponseCardCreate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.content_v2_cards_update_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.content_v2_cards_update_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def content_v2_cards_update_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Update a card  # noqa: E501

        Edits product cards. If you need some product data, get it using <a href=\"./#tag/View/paths/~1content~1v1~1cards~1cursor~1list/post\">Nomenclature list method</a>.  You can not edit or delete barcodes but you can add new ones. You have not to send `photos`, `video` and `tags` and can not edit them.  If this method response is Success (200) but product card was not updated, check errors using <a href=\"./#tag/View/paths/~1content~1v1~1cards~1error~1list/get\">List of failed nomenclature with errors</a> method. Correct the request and try again.  With one request you can edit maximum 100 nomenclatures (`nmID`).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.content_v2_cards_update_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[CardsUpdateBody] body: (required)
        :return: ResponseCardCreate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_v2_cards_update_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `content_v2_cards_update_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/content/v2/cards/update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResponseCardCreate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_v2_cards_upload_add_post(self, **kwargs):  # noqa: E501
        """Adding nomenclature to the card  # noqa: E501

        Adds new nomenclature to the product card. <br>Adding nomenclature is asynchronous, after sending the request is put in a queue for processing. <br><b>Important.</b> If the adding request passed but the nomenclature was not created, check errors using <a href =\"./#tag/View/paths/~1content~1v1~1cards~1error~1list/get\">List of failed nomenclature with errors</a> method. If the nomenclature is listed there, you should correct the reported errors in the adding nomenclature request and resend it.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.content_v2_cards_upload_add_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UploadAddBody body:
        :return: ResponseCardCreate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.content_v2_cards_upload_add_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.content_v2_cards_upload_add_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def content_v2_cards_upload_add_post_with_http_info(self, **kwargs):  # noqa: E501
        """Adding nomenclature to the card  # noqa: E501

        Adds new nomenclature to the product card. <br>Adding nomenclature is asynchronous, after sending the request is put in a queue for processing. <br><b>Important.</b> If the adding request passed but the nomenclature was not created, check errors using <a href =\"./#tag/View/paths/~1content~1v1~1cards~1error~1list/get\">List of failed nomenclature with errors</a> method. If the nomenclature is listed there, you should correct the reported errors in the adding nomenclature request and resend it.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.content_v2_cards_upload_add_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UploadAddBody body:
        :return: ResponseCardCreate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_v2_cards_upload_add_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/content/v2/cards/upload/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResponseCardCreate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_v2_cards_upload_post(self, **kwargs):  # noqa: E501
        """Upload a card  # noqa: E501

        Creating a card is asynchronous, after sending the request is put in a queue for processing.   A product card is valid if at least one nomenclature has been created successfully.   **Important**. If there were errors during queue processing, the nomenclature is considered invalid.      How to create a card:   1. Get parent categories using <a href =\"./#tag/Configurator/paths/~1content~1v1~1object~1parent~1all/get\">Parent categories</a> method.   2. Choose the category and get all subcategories using <a href =\"./#tag/Configurator/paths/~1content~1v1~1object~1all/get\">Product categories list</a>.   3. Choose the subcategory and get all available characteristics using <a href =\"./#tag/Configurator/paths/~1content~1v1~1object~1characteristics~1list~1filter/get\">characteristics methods</a>. Use values from <a href =\"./#tag/Configurator\">Configurator</a> to get values of color, gender, country of origin, season and HS code.   4. Send the request. If the response is Success (200) but the card was not created, check errors using <a href =\"./#tag/View/paths/~1content~1v1~1cards~1error~1list/get\">List of failed nomenclature with errors</a> method.     With one request you can create maximum 100 cards (`imtID`) and 30 nomenclatures (`nmID`) in each card.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.content_v2_cards_upload_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[CardsUploadBody] body:
        :return: ResponseCardCreate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.content_v2_cards_upload_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.content_v2_cards_upload_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def content_v2_cards_upload_post_with_http_info(self, **kwargs):  # noqa: E501
        """Upload a card  # noqa: E501

        Creating a card is asynchronous, after sending the request is put in a queue for processing.   A product card is valid if at least one nomenclature has been created successfully.   **Important**. If there were errors during queue processing, the nomenclature is considered invalid.      How to create a card:   1. Get parent categories using <a href =\"./#tag/Configurator/paths/~1content~1v1~1object~1parent~1all/get\">Parent categories</a> method.   2. Choose the category and get all subcategories using <a href =\"./#tag/Configurator/paths/~1content~1v1~1object~1all/get\">Product categories list</a>.   3. Choose the subcategory and get all available characteristics using <a href =\"./#tag/Configurator/paths/~1content~1v1~1object~1characteristics~1list~1filter/get\">characteristics methods</a>. Use values from <a href =\"./#tag/Configurator\">Configurator</a> to get values of color, gender, country of origin, season and HS code.   4. Send the request. If the response is Success (200) but the card was not created, check errors using <a href =\"./#tag/View/paths/~1content~1v1~1cards~1error~1list/get\">List of failed nomenclature with errors</a> method.     With one request you can create maximum 100 cards (`imtID`) and 30 nomenclatures (`nmID`) in each card.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.content_v2_cards_upload_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[CardsUploadBody] body:
        :return: ResponseCardCreate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_v2_cards_upload_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/content/v2/cards/upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResponseCardCreate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
