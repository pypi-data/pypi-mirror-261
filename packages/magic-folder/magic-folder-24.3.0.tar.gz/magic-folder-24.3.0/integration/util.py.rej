--- integration/util.py
+++ integration/util.py
@@ -2,20 +2,37 @@ import sys
 import time
 import json
 from os import mkdir
+from io import BytesIO
 from os.path import exists, join
 from six.moves import StringIO
 from functools import partial
 
-from twisted.internet.defer import Deferred, succeed
-from twisted.internet.protocol import ProcessProtocol
-from twisted.internet.error import ProcessExitedAlready, ProcessDone
+import attr
+
+from twisted.internet.defer import (
+    inlineCallbacks,
+    returnValue,
+    Deferred,
+    succeed,
+)
+from twisted.internet.protocol import (
+    ProcessProtocol,
+)
+from twisted.internet.error import (
+    ProcessExitedAlready,
+    ProcessDone,
+)
 
 import requests
 
 from eliot import (
     Message,
+    start_action,
     current_action,
 )
+from eliot.twisted import (
+    DeferredContext,
+)
 
 from allmydata.util.configutil import (
     get_config,
@@ -231,6 +378,7 @@ class _MagicTextProtocol(ProcessProtocol):
         self._magic_text = magic_text
         self._output = StringIO()
         self._action = current_action()
+        assert self._action is not None
 
     def processEnded(self, reason):
         with self._action.context():
@@ -654,5 +802,128 @@ def await_client_ready(tahoe, timeout=10, liveness=60*2):
     )
 
 
-def magic_folder_cli(request, reactor, node_dir, *argv):
-    return cli(request, reactor, node_dir, "magic-folder", *argv)
+def _run_magic_folder(reactor, request, temp_dir, name, web_port):
+    """
+    Start a magic-folder process.
+
+    :param reactor: The reactor to use to launch the process.
+    :param request: The pytest request object to use for cleanup.
+    :param temp_dir: The directory in which to find a Tahoe-LAFS node.
+    :param name: The alias of the Tahoe-LAFS node.
+
+    :return Deferred[IProcessTransport]: The started process.
+    """
+    node_dir = join(temp_dir, name)
+
+    magic_text = "Completed initial Magic Folder setup"
+    proto = _MagicTextProtocol(magic_text)
+
+    coverage = request.config.getoption('coverage')
+    def optional(flag, elements):
+        if flag:
+            return elements
+        return []
+
+    args = [
+        sys.executable,
+        "-m",
+    ] + optional(coverage, [
+        "coverage",
+        "run",
+        "-m",
+    ]) + [
+        "magic_folder",
+    ] + optional(coverage, [
+        "--coverage",
+    ]) + [
+        "--node-directory",
+        node_dir,
+        "run",
+        "--web-port",
+        web_port,
+    ]
+    Message.log(
+        message_type=u"integration:run-magic-folder",
+        coverage=coverage,
+        args=args,
+    )
+    transport = reactor.spawnProcess(
+        proto,
+        sys.executable,
+        args,
+    )
+    request.addfinalizer(partial(_cleanup_tahoe_process, transport, proto.exited))
+    with start_action(action_type=u"integration:run-magic-folder").context():
+        ctx = DeferredContext(proto.magic_seen)
+        ctx.addCallback(lambda ignored: transport)
+        return ctx.addActionFinish()
+
+
+@inlineCallbacks
+def _pair_magic_folder(reactor, alice_invite, alice, bob):
+    print("Joining bob to magic-folder")
+    yield _command(
+        "--node-directory", bob.node_directory,
+        "join",
+        "--poll-interval", "1",
+        alice_invite,
+        bob.magic_directory,
+    )
+
+    # before magic-folder works, we have to stop and restart (this is
+    # crappy for the tests -- can we fix it in magic-folder?)
+    yield bob.restart_magic_folder()
+
+    returnValue((alice.magic_directory, bob.magic_directory))
+
+
+@inlineCallbacks
+def _generate_invite(reactor, inviter, invitee_name):
+    """
+    Create a new magic-folder invite.
+
+    :param MagicFolderEnabledNode inviter: the node who will generate the invite
+
+    :param str invitee: the name of the node who will be invited
+    """
+    action_prefix = u"integration:{}:magic_folder".format(inviter.name)
+    with start_action(action_type=u"{}:create".format(action_prefix)):
+        print("Creating magic-folder for {}".format(inviter.node_directory))
+        yield _command(
+            "--node-directory", inviter.node_directory,
+            "create",
+            "--poll-interval", "2", "magik:", inviter.name, inviter.magic_directory,
+        )
+
+    with start_action(action_type=u"{}:invite".format(action_prefix)) as a:
+        print("Inviting '{}' to magic-folder for {}".format(invitee_name, inviter.node_directory))
+        invite = yield _command(
+            "--node-directory", inviter.node_directory,
+            "invite",
+            "magik:", invitee_name,
+        )
+        a.add_success_fields(invite=invite)
+
+    with start_action(action_type=u"{}:restart".format(action_prefix)):
+        # before magic-folder works, we have to stop and restart (this is
+        # crappy for the tests -- can we fix it in magic-folder?)
+        yield inviter.restart_magic_folder()
+    returnValue(invite)
+
+
+
+@inlineCallbacks
+def _command(*args):
+    """
+    Runs a single magic-folder command with the given arguments as CLI
+    arguments to `magic-folder`. If the exit-code is not 0, an
+    exception is raised.
+
+    :returns: stdout
+    """
+    o = MagicFolderCommand()
+    o.stdout = BytesIO()
+    o.parseOptions(args)
+    return_value = yield do_magic_folder(o)
+    assert 0 == return_value
+    returnValue(o.stdout.getvalue())
