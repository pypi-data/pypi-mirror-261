from __future__ import annotations

from opentelemetry import context
from opentelemetry.sdk.trace import ReadableSpan, Span, SpanProcessor

from logfire._constants import (
    ATTRIBUTES_LOG_LEVEL_NAME_KEY,
    ATTRIBUTES_LOG_LEVEL_NUM_KEY,
    ATTRIBUTES_MESSAGE_KEY,
    ATTRIBUTES_MESSAGE_TEMPLATE_KEY,
    ATTRIBUTES_SPAN_TYPE_KEY,
    LEVEL_NUMBERS,
    PENDING_SPAN_NAME_SUFFIX,
)


class SpanProcessorWrapper(SpanProcessor):
    """Wrapper around other processors to intercept starting and ending spans with our own global logic.

    Suppresses starting/ending if the current context has a `suppress_instrumentation` value.
    Tweaks the send/receive span names generated by the ASGI middleware.
    """

    def __init__(self, processor: SpanProcessor) -> None:
        self.processor = processor

    def on_start(
        self,
        span: Span,
        parent_context: context.Context | None = None,
    ) -> None:
        if context.get_value('suppress_instrumentation'):
            return
        self.processor.on_start(span, parent_context)

    def on_end(self, span: ReadableSpan) -> None:
        if context.get_value('suppress_instrumentation'):
            return
        span = _tweak_asgi_span_name(span)
        span = _tweak_http_route_messages(span)
        self.processor.on_end(span)

    def shutdown(self) -> None:
        self.processor.shutdown()

    def force_flush(self, timeout_millis: int = 30000) -> bool:
        return self.processor.force_flush(timeout_millis)


def _tweak_asgi_span_name(span: ReadableSpan) -> ReadableSpan:
    """Make the name/message of spans generated by OTEL's ASGI middleware more useful.

    For example, a single request will typically generate two 'send' spans with the same message,
    e.g. 'GET /foo http send'. This function may add part of the ASGI event type to the name to make it more useful,
    so instead it shows e.g. 'http send response.start' and 'http send response.body'.
    """
    instrumentation_scope = span.instrumentation_scope
    if not (instrumentation_scope and instrumentation_scope.name == 'opentelemetry.instrumentation.asgi'):
        return span

    if not (name := span.name).endswith(
        (
            ' http send',
            ' http receive',
            ' websocket send',
            ' websocket receive',
        )
    ):
        return span

    attributes = span.attributes or {}
    typ = attributes.get('type')
    if (
        not (isinstance(typ, str) and typ.startswith(('http.', 'websocket.')))
        # No point in adding anything in this case, otherwise it'd say e.g. 'websocket send send'.
        # No other event types in https://asgi.readthedocs.io/en/latest/specs/www.html are redundant like this.
        or typ in ('websocket.send', 'websocket.receive')
    ):
        return span

    # Strip the 'http.' or 'websocket.' prefix from the event type and add it to the span name.
    new_name = f'{name} {typ.split(".", 1)[1]}'
    if attributes.get(ATTRIBUTES_MESSAGE_KEY) == name:  # this should usually be the case
        attributes = {
            **attributes,
            ATTRIBUTES_MESSAGE_KEY: new_name,
            ATTRIBUTES_LOG_LEVEL_NAME_KEY: 'debug',
            ATTRIBUTES_LOG_LEVEL_NUM_KEY: LEVEL_NUMBERS['debug'],
        }

    return ReadableSpan(
        name=new_name,
        context=span.context,
        parent=span.parent,
        resource=span.resource,
        attributes=attributes,
        events=span.events,
        links=span.links,
        status=span.status,
        kind=span.kind,
        start_time=span.start_time,
        end_time=span.end_time,
        instrumentation_scope=instrumentation_scope,
    )


def _tweak_http_route_messages(span: ReadableSpan) -> ReadableSpan:
    """Change the logfire.msg attribute of certain spans from e.g. 'GET /route/{param}' to 'GET /route/actual_value'."""
    attributes = span.attributes or {}

    # Check that this generally looks like a span not generated by logfire methods.
    # This is intended for OTEL instrumentations of frameworks like FastAPI, but written to be general.
    if ATTRIBUTES_MESSAGE_TEMPLATE_KEY in attributes:
        return span

    name = span.name
    if attributes.get(ATTRIBUTES_SPAN_TYPE_KEY) == 'pending_span':
        non_pending_name = name[: -len(PENDING_SPAN_NAME_SUFFIX)]
    else:
        non_pending_name = name
    if non_pending_name != attributes.get(ATTRIBUTES_MESSAGE_KEY):
        return span

    # Check that the current name/message has the form that we want to change.
    route = attributes.get('http.route')
    if not (route and isinstance(route, str) and non_pending_name.endswith(route)):
        return span
    minus_route = non_pending_name[: -len(route)]
    method = attributes.get('http.method')
    if not isinstance(method, str):
        method_prefix = ''
    else:
        method_prefix = f'{method} '
    if minus_route not in (method_prefix, ''):
        return span

    # Replace the template route (e.g. '/route/{param}')
    # with the actual URL path of the specific request.
    target = attributes.get('http.target')
    if not (target and isinstance(target, str)):
        return span
    attributes = {**attributes, ATTRIBUTES_MESSAGE_KEY: minus_route + target}

    return ReadableSpan(
        # Note that the span name stays the same, i.e. it should be low cardinality,
        # similar to how we use the message template for logfire span names.
        name=name,
        context=span.context,
        parent=span.parent,
        resource=span.resource,
        attributes=attributes,
        events=span.events,
        links=span.links,
        status=span.status,
        kind=span.kind,
        start_time=span.start_time,
        end_time=span.end_time,
        instrumentation_scope=span.instrumentation_scope,
    )
