# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_sigs.ipynb.

# %% auto 0
__all__ = ['put_var_in_signature', 'signature_from_annotations', 'signature_from_callable', 'get_signature_defaults',
           'signature_from_bound']

# %% ../nbs/05_sigs.ipynb 6
from inspect import (signature, Signature, BoundArguments, Parameter, get_annotations, _ParameterKind as ParamKind)

# %% ../nbs/05_sigs.ipynb 8
from typing import (Callable,)

# %% ../nbs/05_sigs.ipynb 10
#| export


# %% ../nbs/05_sigs.ipynb 12
#| export


# %% ../nbs/05_sigs.ipynb 14
from .type import (AnnotationSignatureOptions, CallableSignatureOptions, ArgsKind, KwdsKind, P)
from .grds import (isnone, notnone, istype, issig, notempty, isvarg, isvkws, isparam)
from .cons import (ARGS_KIND, KWDS_KIND, _ARGS, _KWDS)
from .util import (parameter_defaults, hasvarg, hasvkws)

# %% ../nbs/05_sigs.ipynb 17
def put_var_in_signature(
    __signature: Signature,
    __varpos: bool = True,
    __varkws: bool = True,
) -> Signature:
    sig = __signature
    prms = list(sig.parameters.values())
    ret = sig.return_annotation
    if not hasvarg(sig) and __varpos:
        for i, p in enumerate(prms):
            if p.kind in ARGS_KIND: continue
            break
        prms.insert(i + 1, _ARGS)
        # prms = [_ARGS, ] + prms
        sig = Signature(prms, return_annotation=ret)
    
    if not hasvkws(sig) and __varkws: 
        prms += [_KWDS, ]
        sig = Signature(prms, return_annotation=ret)
    return sig

# %% ../nbs/05_sigs.ipynb 19
def signature_from_annotations(
    fn: Callable, 
    *, 
    __force_defaults: bool = False, 
    __varpos: bool = True,
    __varkws: bool = True,
    __return: type | None = None,
    **kwargs: AnnotationSignatureOptions
) -> Signature:
    '''Generate a function signature based on annotations and optionally specified defaults.
    
    Parameters
    ----------
    fn : Callable
        The function to analyze.
        
    __force_defaults : bool, default: False
        If True, forces the use of default values for all parameters, by default False.
        
    **kwargs : AnnotationSignatureOptions
        Additional options to control the signature generation. These can include
        specific default values for some or all of the annotated parameters.
    
    Returns
    -------
    Signature
        A `Signature` object representing the generated signature for the function.
        
    Notes
    -----
    - This function relies on the annotations defined in the function to generate
      the signature. It does not inspect the function body or default parameter values.
    - If `__force_defaults` is True, parameters without explicit defaults in `kwargs`
      will be given a default value of None.
    '''
    __return = kwargs.get('__return', __return)
    __force_defaults = kwargs.get('__force_defaults', __force_defaults)
    anns = get_annotations(fn)
    return_annotation = anns.pop('return', __return if notnone(__return) else None)
    kwds, prms = list(anns.keys()), list()
    
    for kwd, ann in zip(kwds, anns.values()):
        val = kwargs.get(kwd, None)
        if isnone(val) and istype(ann):
            try: # try to instantiate the annotation 
                val = ann()
            except: # if it fails, set the default value to None
                val = None


        pkind = Parameter.POSITIONAL_OR_KEYWORD                
        if kwd == 'args' and __varpos: pkind = Parameter.VAR_POSITIONAL
        if kwd == 'kwargs' and __varkws: pkind = Parameter.VAR_KEYWORD
        
        prm = Parameter(kwd, kind=pkind, annotation=ann)
        if val is not None or __force_defaults: prm = prm.replace(default=val)
        prms.append(prm)
    
    sig = Signature(prms, return_annotation=return_annotation)
    return put_var_in_signature(sig, __varpos, __varkws)

# %% ../nbs/05_sigs.ipynb 21
def signature_from_callable(
    fn: Callable, *,
    __signature: Signature | None = None,
    __force_defaults: bool = False,
    __varpos: bool = True,
    __varkws: bool = True,
    **kwargs: CallableSignatureOptions
) -> Signature:
    '''Generate a function signature from a callable, with options to enforce defaults.
    
    Parameters
    ----------
    fn : Callable
        The callable to generate a signature for.
        
    __signature : Signature, optional
        A pre-existing signature to use instead of generating a new one.
        
    __force_defaults : bool, default: False
        Force the inclusion of default values in the generated signature.
        
    **kwargs : CallableSignatureOptions
        Additional options that can influence signature generation.
    
    Returns
    -------
    Signature
        A `Signature` object for the callable.
    
    Notes
    -----
    This function first attempts to retrieve the signature of the callable directly.
    If that fails (e.g., for built-in functions), it falls back to generating a
    signature based on annotations or provided defaults.
    
    Examples
    --------
    >>> def example_func(a, b=2):
    ...     return a + b
    >>> signature_from_callable(example_func)
    <Signature (a, b=2)>
    '''
    __signature = kwargs.get('__signature', __signature)
    __force_defaults = kwargs.get('__force_defaults', __force_defaults)
    __varpos = kwargs.get('__varpos', __varpos)
    __varkws = kwargs.get('__varkws', __varkws)
    try: return signature(fn); # Try to get the signature of the function
    except ValueError: ...     # Handle built-in functions
    if issig(__signature): 
        return __signature     # Use default signature if provided
    try: 
        return signature_from_annotations(
        fn, 
        __force_defaults=__force_defaults, 
        __varpos=__varpos, 
        __varkws=__varkws, 
        **kwargs
    )
    except: 
        return put_var_in_signature(Signature([]), __varpos, __varkws)

# %% ../nbs/05_sigs.ipynb 23
def get_signature_defaults(
    fn: Callable, 
    *, 
    __signature: Signature | None = None, 
    __force_defaults: bool = False,
    __drop_nones: bool = True,
    __varpos: bool = True,
    __varkws: bool = True,
    **kwargs: CallableSignatureOptions
) -> dict:
    '''
    Retrieve the default values from a function's signature, with customization options.
    
    Parameters
    ----------
    fn : Callable
        The function to analyze.
        
    __signature : Signature, optional
        A specific signature to use, bypassing automatic generation.
        
    __force_defaults : bool, default: False
        If True, ensures all parameters are included, even if they have no defaults.

    __drop_nones : bool, default: True
        If True, parameters with a default value of None are omitted from the result.
        
    **kwargs : CallableSignatureOptions
        Additional options for default value handling and signature customization.
    
    Returns
    -------
    dict
        A dictionary mapping parameter names to their default values.
    '''
    __varpos = kwargs.get('__varpos', __varpos)
    __varkws = kwargs.get('__varkws', __varkws)
    sig = signature_from_callable(
        fn, __signature=__signature, __force_defaults=__force_defaults, 
        __varpos=__varpos, __varkws=__varkws, **kwargs
    )
    # get the defaults from the signature
    defaults = parameter_defaults(sig)
    
    # update the defaults with the kwargs
    defaults.update({k:v for k,v in kwargs.items() if k in defaults})
    if not __drop_nones: defaults = {k:v for k,v in defaults.items() if not isnone(v)}
    return defaults

# %% ../nbs/05_sigs.ipynb 25
def signature_from_bound(
    bound: BoundArguments, 
    __args: bool = False,
    __kwds: bool = False,
    __args_kind: ArgsKind = ParamKind.POSITIONAL_OR_KEYWORD,
    __kwds_kind: KwdsKind = ParamKind.KEYWORD_ONLY,
    __zero_idx: bool = False
) -> Signature:
    '''Constructs a function signature from bound arguments with customization options.
    
    Parameters
    ----------
    bound : BoundArguments
        The bound arguments object from which to construct the signature.
        
    __args : bool, default: False
        Include positional arguments in the signature.
        
    __kwds : bool, default: False
        Include keyword arguments in the signature.
        
    __args_kind : ArgsKind, default: ParamKind.POSITIONAL_OR_KEYWORD
        The kind of parameter to use for positional arguments.
        
    __kwds_kind : KwdsKind, default: ParamKind.KEYWORD_ONLY
        The kind of parameter to use for keyword arguments.
        
    __zero_idx : bool, default: False
        Start indexing positional arguments from zero.
    
    Returns
    -------
    Signature
        The constructed signature that reflects the binding of arguments.
    '''
    if __args_kind not in ARGS_KIND: __args_kind = ParamKind.POSITIONAL_OR_KEYWORD
    if __kwds_kind not in KWDS_KIND: __kwds_kind = ParamKind.KEYWORD_ONLY
        
    params: dict[str, Parameter] = {}
    argidx, kwsidx = -1, -1
    for i, (a, p) in enumerate(bound.signature.parameters.items()):
        val = bound.arguments.get(a, p)
        
        if p.kind in (Parameter.VAR_POSITIONAL, Parameter.VAR_KEYWORD): 
            params[a] = p.replace()
            if isvarg(p): argidx = i
            if isvkws(p): kwsidx = i
            continue

        if isparam(val): 
            if notempty(val.default): 
                val = val.default
            else: 
                val = None
            
        p = p.replace(default=val, annotation=type(val))
        params[a] = p
        
    args: dict[str, Parameter] = {}
    for a, v in enumerate(bound.arguments.get('args', tuple())):
        kind = 'optional' if __args_kind == ParamKind.POSITIONAL_OR_KEYWORD else 'positional'
        name = f'{kind}_{a + (0 if __zero_idx else 1)}'
        p = Parameter(name=name, kind=__args_kind, default=v, annotation=type(v))
        args[a] = p
        
    kwargs: dict[str, Parameter] = {}
    for a, v in bound.arguments.get('kwargs', dict()).items():
        p = Parameter(name=a, kind=__kwds_kind, default=v, annotation=type(v))
        kwargs[a] = p
       
    result: dict[str, Parameter] = params.copy()
    hasarg = argidx > -1 and __args
    haskws = kwsidx > -1 and __kwds
    if hasarg or haskws:
        result = {}
        for i, (a, p) in enumerate(params.items()):
            if i == argidx and __args:
                for k, v in args.items():
                    result[k] = v
            if i == kwsidx and __kwds:
                for k, v in kwargs.items():
                    result[k] = v
            result[a] = p
           
    bsig = bound.signature.replace(parameters=result.values())
    return bsig
