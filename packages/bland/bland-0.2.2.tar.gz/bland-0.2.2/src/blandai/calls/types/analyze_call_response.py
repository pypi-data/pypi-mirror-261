# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ...commons.types.status import Status
from ...core.datetime_utils import serialize_datetime

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore


class AnalyzeCallResponse(pydantic.BaseModel):
    status: Status = pydantic.Field()
    """
    Will be `success` if the request was successful.
    """

    message: str = pydantic.Field()
    """
    Confirms the request was successful, or provides an error message if the request failed.
    """

    answers: typing.List[typing.List[typing.Any]] = pydantic.Field()
    """
    Contains the analyzed answers for the call in an array.
    """

    credits_used: int = pydantic.Field()
    """
    Token-based price for the analysis request.
    
    As a rough estimate, the base cost is `0.003` credits with an additional `0.0015` credits per call in the call.
    
    Longer call transcripts and higher numbers of questions can increase the cost, however the cost scales very effectively with calls vs. individual calls.
    """

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        smart_union = True
        json_encoders = {dt.datetime: serialize_datetime}
